---
title: "P. Falciparum Lifecycle - Comparing Bozdech and TradeSeq"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, results='hide', message=FALSE, warning=FALSE}
library(readxl)
library(scran)
library(slingshot)
library(tradeSeq)
library(BiocParallel)
library(blase)
library(scater)
library(utils)
library(ami)
library(fs)
```

```{r randomseed}
RNGversion("3.5.0")
SEED = 7
set.seed(SEED)
```

```{r concurrency}
N_CORES = 4
if (ami::using_ci()) {
  N_CORES = 2
}
```

In this article we will use BLASE to map *Plasmodium falciparum* microarray data of the asexual lifecycle ([Painter et al. 2018](https://doi.org/10.1038/s41467-018-04966-3), 3d7 strain) onto the Malaria Cell Atlas ([Dogga et al. 2023](https://www.science.org/doi/10.1126/science.adj4088), 7G8 & NF54 strains) to try and annotate it over a 48 hour period.

We will also investigate the Bozdech method for finding genes that change over the lifecycle, and compare it with TradeSeq's results.

## Load Data

```{r getData}
root_dir = tools::R_user_dir("BLASE", "data")

article_dir = path(root_dir, "3d7_lifecycle")
if (!dir.exists(article_dir)) {
  dir.create(article_dir, recursive = TRUE)
}

bulk_path = path(article_dir, "3d7_bulk_timepoints", ext="xlsx")
if (!file.exists(bulk_path)) {
  download.file('https://static-content.springer.com/esm/art%3A10.1038%2Fs41467-018-04966-3/MediaObjects/41467_2018_4966_MOESM4_ESM.xlsx', bulk_path)
}else {
  print("Using cached")
}

bulk = as.data.frame(read_excel(bulk_path, sheet = "Estimated Total Abundance"))
rownames(bulk) = bulk$`Gene ID`
rownames(bulk) = gsub(x=rownames(bulk), pattern="_", replacement="-", fixed=TRUE)
bulk = bulk[7:nrow(bulk),]
bulk = subset(bulk, , -c(`Gene ID`, `Annotation`, `Peak Time (hpi)`, `p-value`))

```

## Prepare SC

Here we use the Malaria Cell Atlas's *Plasmodium falciparum* 10x data (with some preprocessing described in [generate-MCA-pf-object](generate-MCA-pf-object).

```{r loadSC}
data(processed_MCA_PF_SCE, package="blase")
gridExtra::grid.arrange(
  plotPCA(processed_MCA_PF_SCE, colour_by="STAGE_LR"),
  plotUMAP(processed_MCA_PF_SCE, colour_by="STAGE_LR"),
  plotPCA(processed_MCA_PF_SCE, colour_by="DAY"),
  plotUMAP(processed_MCA_PF_SCE, colour_by="DAY"),
  plotPCA(processed_MCA_PF_SCE, colour_by="STRAIN"),
  plotUMAP(processed_MCA_PF_SCE, colour_by="STRAIN"),
  plotPCA(processed_MCA_PF_SCE, colour_by="slingPseudotime_1"),
  plotUMAP(processed_MCA_PF_SCE, colour_by="slingPseudotime_1"),
  ncol=2
)
```
```{r}
gridExtra::grid.arrange(
  plotUMAP(processed_MCA_PF_SCE, colour_by="STAGE_LR"),
  plotUMAP(processed_MCA_PF_SCE, colour_by="slingPseudotime_1"),
  ncol=2
)
```
## Get Genes

### TradeSeq

```{r tradeSeq}
associationTestResult <- associationTest(processed_MCA_PF_SCE, lineages=T, global=F, contrastType="consecutive")
genelist = blase::get_top_n_genes(associationTestResult, n_genes = 500, lineage = 1)
```

```{r}
res = find_best_params(processed_MCA_PF_SCE,
                       genelist,
                       split_by="pseudotime_range",
                       pseudotime_slot="slingPseudotime_1",
                       bins_count_range = seq.int(10, 14, 1),
                       gene_count_range = seq.int(12, 192, 3))
plot_find_best_params_results(res)
```

```{r}
res2 = find_best_params(processed_MCA_PF_SCE,
                       genelist,
                       split_by="pseudotime_range",
                       pseudotime_slot="slingPseudotime_1",
                       bins_count_range = 12,
                       gene_count_range = seq.int(12, 192, 3))
plot_find_best_params_results(res2)
```

### Get Bozdech Genes

Bozdech's paper describes using a fourier transform on the gene expression of cells ordered by time. This gives the amplitude and phase of the peak of waves. In this case we assume that many genes important for lifecycle development are turned on temporarily during the lifecycle, then turned off, resulting in a clear peak. They then find the top "power" genes by analysing how strong peaks are versus the average expression of the gene over pseudotime.

BLASE provides a convenience function to perform this analysis, and also allows you to select the top genes by amplitude and explained variance if preferred. See the documentation for `select_genes_by_fourier_method()` for more information. It is noteworthy that BLASE will force these genes to be selected to cover a wide range of pseudotime by default, instead of simply the top power genes.

```{r}
waves = get_waves(processed_MCA_PF_SCE, "slingPseudotime_1", n_cores=N_CORES)
fourier_power_genes = select_genes_by_fourier_method(processed_MCA_PF_SCE, waves, n_groups=100, top_n_per_group=2)
head(fourier_power_genes)
```

### Compare Gene Lists

Here we generate a heatmap of log counts of the selected genes, ordered by pseudotime. Genes are ordered by their phase in pseudotime.

#### All Genes

```{r}
gene_selection_matrix(processed_MCA_PF_SCE, waves, n_cores=N_CORES, target_matrix_size=nrow(waves))
```

#### TradeSeq Genes

```{r}
gene_selection_matrix(processed_MCA_PF_SCE, waves, genes=genelist[0:300], n_cores=N_CORES, target_matrix_size=300)
```

#### Bozdech Genes

```{r}
gene_selection_matrix(processed_MCA_PF_SCE, waves, genes=rownames(fourier_power_genes), n_cores=N_CORES, target_matrix_size=length(unique(rownames(fourier_power_genes))))
```

## Use each gene list

### Using TradeSeq genes

Now we will use the genes generated by TradeSeq.

```{r}
genes = 300
bins = 12
processed_MCA_PF_SCE = assign_pseudotime_bins(processed_MCA_PF_SCE, pseudotime_slot="slingPseudotime_1", n_bins=bins, split_by="pseudotime_range")
plotUMAP(processed_MCA_PF_SCE, color="pseudotime_bin")
gridExtra::grid.arrange(
  plotUMAP(processed_MCA_PF_SCE, color="STAGE_LR"),
  plotUMAP(processed_MCA_PF_SCE, color="pseudotime_bin"),
  ncol=2
)
```

```{r}
blase_data = as.blaseData(processed_MCA_PF_SCE, pseudotime_slot="slingPseudotime_1", n_bins=bins, split_by="pseudotime_range")
genes(blase_data) = genelist[1:genes]
evaluate_parameters(blase_data, make_plot = TRUE)
processed_MCA_PF_SCE = assign_pseudotime_bins(processed_MCA_PF_SCE, pseudotime_slot="slingPseudotime_1", n_bins=bins, split_by="pseudotime_range")
```

```{r}
## Map Bulk data onto Single Cell
mapping_results = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(blase_data, bulkname, bulk)
  mapping_results = c(mapping_results, res)
}

blase_tradeseq_results_plot = blase::plot_mapping_result_heatmap(rev(mapping_results), annotate = TRUE)
blase_tradeseq_results_plot + ggtitle('BLASE (TradeSeq)')
```

### Using Bozdech Genes

And here we will use the genes generated by Bozdech's Fourier method.

```{r}
blase_data = as.blaseData(processed_MCA_PF_SCE, pseudotime_slot="slingPseudotime_1", n_bins=bins, split_by="pseudotime_range")
genes(blase_data) = rownames(fourier_power_genes)
evaluate_parameters(blase_data, make_plot = TRUE)
```

```{r}
## Map Bulk data onto Single Cell
mapping_results_fourier = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(blase_data, bulkname, bulk)
  mapping_results_fourier = c(mapping_results_fourier, res)
}

blase_bozdech_results_plot = blase::plot_mapping_result_heatmap(rev(mapping_results_fourier), annotate = TRUE)
blase_bozdech_results_plot + ggtitle('BLASE (Bozdech et al. adapted)')
```

## Comparison With Existing Tools
```{r}
getwd()
source('comparison_functions.R')
rownames(bulk) <- gsub("-", "_", rownames(bulk))
rownames(processed_MCA_PF_SCE) <- gsub("-", "_", rownames(processed_MCA_PF_SCE))

colnames(bulk) <- gsub(" ", "_", colnames(bulk))


processed_MCA_PF_SCE$STAGE_HR <- droplevels(processed_MCA_PF_SCE$STAGE_HR) # Remove lifecycle stages that have been removed
```

```{r}
processed_MCA_PF_SCE
```

### SCDC
```{r SCDC}
# SCDC has issues when a cell type is only in one sample (https://github.com/meichendong/SCDC/issues/37)
# See also `table (processed_MCA_PF_SCE$STAGE_HR, processed_MCA_PF_SCE$DAY)`
scdc_results <- SCDC(processed_MCA_PF_SCE, 'pseudotime_bin', bulk, 'DAY')
print(scdc_results$prop.est.mvw)

to_plot <- as.data.frame(scdc_results$prop.est.mvw)
to_plot$BulkID <- rownames(to_plot)
to_plot <- melt(to_plot)

scdc_results_plot = ggplot(to_plot, aes(variable, BulkID)) +
  geom_tile(aes(fill = value), colour = "white") +
  scale_fill_gradient(low = "white", high = "red", limits=c(0,1)) +
  scale_y_discrete(limits = paste0(0:47, "_hpi")) +
  scale_x_discrete(limits = sort(unique(processed_MCA_PF_SCE$pseudotime_bin))) +
  ggtitle("SCDC")
scdc_results_plot + geom_text(aes(label = round(value, 2)))
```

### MuSiC
```{r music}
# Music requires at least 2 samples, and all cells represented across all samples
music_results <- MUSIC(processed_MCA_PF_SCE, 'pseudotime_bin', bulk, 'DAY')
print(music_results$prop.est.mvw)

to_plot <- as.data.frame(music_results$Est.prop.weighted)
to_plot$BulkID <- rownames(to_plot)
to_plot <- melt(to_plot)

music_results_plot = ggplot(to_plot, aes(variable, BulkID)) +
  geom_tile(aes(fill = value), colour = "white") +
  scale_fill_gradient(low = "white", high = "red", limits=c(0,1)) +
  scale_y_discrete(limits = paste0(0:47, "_hpi")) +
  scale_x_discrete(limits = sort(unique(processed_MCA_PF_SCE$pseudotime_bin))) +
  ggtitle("MuSiC")
music_results_plot + geom_text(aes(label = round(value, 2)))
```

### CibersortX

```{r cibersort}
cibersort_results <- CibersortX(processed_MCA_PF_SCE, 'pseudotime_bin', bulk, N_CORES)
colnames(cibersort_results) = gsub(x=colnames(cibersort_results), pattern="c", replacement="", fixed=TRUE)
to_plot <- as.data.frame(cibersort_results)
to_plot <- subset(to_plot, select = -c(P.value, Correlation, RMSE))
to_plot$BulkID <- rownames(to_plot)
to_plot <- melt(to_plot)

cibersortx_results_plot = ggplot(to_plot, aes(variable, Mixture)) +
  geom_tile(aes(fill = value), colour = "white") +
  scale_fill_gradient(low = "white", high = "red", limits=c(0,1)) +
  scale_y_discrete(limits = paste0(0:47, "hpi")) +
  scale_x_discrete(limits = sort(unique(processed_MCA_PF_SCE$pseudotime_bin))) + 
  ggtitle("CibersortX")
cibersortx_results_plot + geom_text(aes(label = round(value, 2)))
```

### Summary Plot
```{r}
gridExtra::grid.arrange(
  blase_tradeseq_results_plot + scale_y_discrete(limits = paste(0:47, "hpi")),
  blase_bozdech_results_plot + scale_y_discrete(limits = paste(0:47, "hpi")),
  scdc_results_plot,
  music_results_plot,
  cibersortx_results_plot,
  ncol=2
)
```

## Analysing Accuracy

The Painter et al. paper describes the following timepoints HPI matching to lifecycle stages, in figure 1:

-   5-15: Ring

-   15-34: Troph

-   34-40: Schizont

-   40-45: Merozoites

```{r}
expected_rings_hpi = 5:15
expected_trophs_hpi = 16:34
expected_schizont_hpi = 35:42
```

Below, we can see how out bins are aligned with lifecycle stages

```{r}
table(processed_MCA_PF_SCE@colData[c("STAGE_LR", "pseudotime_bin")])
```

Now we can check the accuracy of these techniques, according to prior knowledge.

```{r, include=FALSE}
called_ring_bins = sort(unique(processed_MCA_PF_SCE@colData[processed_MCA_PF_SCE@colData[["STAGE_LR"]] == "ring",][["pseudotime_bin"]]))
called_troph_bins = sort(unique(processed_MCA_PF_SCE@colData[processed_MCA_PF_SCE@colData[["STAGE_LR"]] == "trophozoite",][["pseudotime_bin"]]))
called_schizont_bins = sort(unique(processed_MCA_PF_SCE@colData[processed_MCA_PF_SCE@colData[["STAGE_LR"]] == "schizont",][["pseudotime_bin"]]))
```

```{r, include=FALSE}
analyse_mapping_results = function(mapping_results) {
  results = data.frame()
  
  # For every bulk
  for (bulk_sample in mapping_results) {
    
    # Get timepoint from hpi text
    timepoint = as.numeric(gsub(x=bulk_sample@bulk_name, pattern=" hpi", replacement=""))
    
    # Calculate Expected stage
    expected_stage_from_hpi = "NA"
    if (timepoint %in% expected_rings_hpi) {
      expected_stage_from_hpi = "Rings"
    } else if (timepoint %in% expected_trophs_hpi) {
      expected_stage_from_hpi = "Trophs"
    } else if (timepoint %in% expected_schizont_hpi) {
      expected_stage_from_hpi = "Schizonts"
    } else {
      next
    }
    
    # Calculate Stage that BLASE predicted
    blase_predicted_stage = ""
    if (bulk_sample@best_bin %in% called_ring_bins) {
      blase_predicted_stage = paste(blase_predicted_stage,"Rings")
    }
    if (bulk_sample@best_bin %in% called_troph_bins) {
      blase_predicted_stage = paste(blase_predicted_stage,"Trophs")
    }
    if (bulk_sample@best_bin %in% called_schizont_bins) {
      blase_predicted_stage = paste(blase_predicted_stage,"Schizonts")
    }
    
    # Collate Results
    results = rbind(results, data.frame(
      timepoint=timepoint, 
      expected_stage_from_hpi=expected_stage_from_hpi, 
      blase_predicted_stage=blase_predicted_stage,
      bin_call=bulk_sample@best_bin,
      confident_call=bulk_sample@confident_mapping))
  
  }
  return(results)
}

describe_results = function(result_set) {
  incorrect = nrow(result_set[!mapply(`grepl`, result_set$expected_stage_from_hpi, result_set$blase_predicted_stage),])
  confident = nrow(result_set[result_set$confident_call,])
  incorrect_confident = nrow(result_set[!mapply(`grepl`, result_set$expected_stage_from_hpi, result_set$blase_predicted_stage) & result_set$confident_call,])
  
  return(paste(
    paste(incorrect, "wrong out of", nrow(result_set)),
    paste(incorrect_confident, "confident calls wrong out of", confident),
    sep=", "
  ))
}
```

```{r, include=FALSE}
analyse_mapping_results_other_tools = function(results_df) {
  results = data.frame()
  
  # For every bulk
  for (timepoint in rownames(results_df)) {
    timepoint = as.numeric(gsub(x=timepoint, pattern="hpi", replacement="", fixed=TRUE))

    # Calculate Expected stage
    expected_stage_from_hpi = "NA"
    if (timepoint %in% expected_rings_hpi) {
      expected_stage_from_hpi = "Rings"
    } else if (timepoint %in% expected_trophs_hpi) {
      expected_stage_from_hpi = "Trophs"
    } else if (timepoint %in% expected_schizont_hpi) {
      expected_stage_from_hpi = "Schizonts"
    } else {
      next
    }
    
    # Calculate Stage predicted
    
    rowdata = results_df[timepoint,]
    predicted_bin <- colnames(rowdata)[max.col(rowdata, ties.method='first')]
    predicted_stage = ""
    if (predicted_bin %in% called_ring_bins) {
      predicted_stage = paste(predicted_stage,"Rings")
    }
    if (predicted_bin %in% called_troph_bins) {
      predicted_stage = paste(predicted_stage,"Trophs")
    }
    if (predicted_bin %in% called_schizont_bins) {
      predicted_stage = paste(predicted_stage,"Schizonts")
    }
    
    # Collate Results
    results = rbind(results, data.frame(
      timepoint=timepoint, 
      expected_stage_from_hpi=expected_stage_from_hpi, 
      blase_predicted_stage=predicted_stage,
      bin_call=predicted_bin))
  
  }
  return(results)
}

describe_results_other_tools = function(result_set) {
  incorrect = nrow(result_set[!mapply(`grepl`, result_set$expected_stage_from_hpi, result_set$blase_predicted_stage),])
  
  return(paste(
    paste(incorrect, "wrong out of", nrow(result_set)),
    sep=", "
  ))
}
```

### Make the dataframes comparable
```{r}
scdc_results_for_comparison = as.data.frame(scdc_results$prop.est.mvw)
rownames(scdc_results_for_comparison) = gsub(x=rownames(scdc_results_for_comparison), pattern="_", replacement="", fixed=TRUE)
scdc_results_for_comparison = scdc_results_for_comparison[ , order(as.numeric(colnames(scdc_results_for_comparison)))]

music_results_for_comparison = as.data.frame(music_results$Est.prop.weighted)
rownames(music_results_for_comparison) = gsub(x=rownames(music_results_for_comparison), pattern="_", replacement="", fixed=TRUE)
music_results_for_comparison = music_results_for_comparison[ , order(as.numeric(colnames(music_results_for_comparison)))]

cibersortx_results_for_comparison = cibersort_results
rownames(cibersortx_results_for_comparison) = cibersortx_results_for_comparison$Mixture
cibersortx_results_for_comparison <- subset(cibersortx_results_for_comparison, select = -c(Mixture, P.value, Correlation, RMSE))
cibersortx_results_for_comparison = cibersortx_results_for_comparison[ , order(as.numeric(colnames(cibersortx_results_for_comparison)))]

scdc_results_for_comparison
music_results_for_comparison
cibersortx_results_for_comparison
```

### View Results
```{r}
results_tradeseq = analyse_mapping_results(mapping_results)
results_fourier = analyse_mapping_results(mapping_results_fourier)

results_scdc = analyse_mapping_results_other_tools(scdc_results_for_comparison)
results_music = analyse_mapping_results_other_tools(music_results_for_comparison)
results_cibersortx = analyse_mapping_results_other_tools(cibersortx_results_for_comparison)

print(paste("Tradeseq:", describe_results(results_tradeseq)))
print(paste("Fourier:", describe_results(results_fourier)))

print(paste("SCDC:", describe_results_other_tools(results_scdc)))
print(paste("MUSIC:", describe_results_other_tools(results_music)))
print(paste("CibersortX:", describe_results_other_tools(results_cibersortx)))

```

## Summary

We've shown here that using Bozdech's method can give better mappings than using tradeseq in this case of the *P. falciparum* lifecycle. Selecting informative genes is vital for BLASE's performance, however this is an non-trivial problem as of now - we reccommend that you select genes carefully and apply prior knowledge of genes that change over the trajectory where possible.

## Session Info

```{r sessionInfo}
sessionInfo()
```
