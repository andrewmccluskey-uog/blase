---
title: "BLASE for Hematopoesis"
author: Andrew McCluskey
date: 20/6/2024
output: rmarkdown::html_vignette
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(blase)
library(fs)
library(Seurat)
library(dplyr)
library(slingshot)
library(tradeSeq)
library(BiocParallel)
library(scran)
library(scater)
library(viridis)
library(gridExtra)
```

First configure R:
```{r, randomseed}
RNGversion("3.5.0")
SEED <- 7
set.seed(SEED)
```

```{r, concurrency}
# N_CORES = 4
if (ami::using_ci()) {
  N_CORES <- 2
}
```

## Load Single Cell
```{r}
data(processed_weng_2024_haematopoiesis, package = "blase")
processed_weng_2024_haematopoiesis

gridExtra::grid.arrange(
  plotUMAP(processed_weng_2024_haematopoiesis, color_by = "STD.CellType", text_by = "STD.CellType"),
  plotUMAP(processed_weng_2024_haematopoiesis, color_by = "slingPseudotime_1"),
  ncol = 1
)
```
## Split Dataset in half
```{r}
processed_weng_2024_haematopoiesis$traintestsplit = round(runif(ncol(processed_weng_2024_haematopoiesis), 0, 1))
blase_train = processed_weng_2024_haematopoiesis[,processed_weng_2024_haematopoiesis$traintestsplit == 0]
blase_test = processed_weng_2024_haematopoiesis[,processed_weng_2024_haematopoiesis$traintestsplit == 1]
```

```{r}
table(processed_weng_2024_haematopoiesis$traintestsplit, processed_weng_2024_haematopoiesis$STD.CellType)
```

### Train Dataset
```{r}
gridExtra::grid.arrange(
  plotUMAP(blase_train, color_by = "STD.CellType", text_by = "STD.CellType"),
  plotUMAP(blase_train, color_by = "slingPseudotime_1"),
  ncol = 1
)
```

### Test Dataset 
```{r}
gridExtra::grid.arrange(
  plotUMAP(blase_test, color_by = "STD.CellType", text_by = "STD.CellType"),
  plotUMAP(blase_test, color_by = "slingPseudotime_1"),
  ncol = 1
)
```

## Set up BLASE
```{r}
expected_trajectory = c(
  'Refined.HSC',
  'HSC', # Haematopoeitic Stem Cell
  'MPP', # multipotent progenitors
  'CMP', # common myeloid progenitor
  'GMP', # granulocyteâ€“monocyte progenitors
  'MDP' # Monocyte-dendritic cell progenitor
  # 'Mono' # Monocytes - excluded as unclear if part of true haematopoiesis process or mature and BM resident
)

start_cell_type <- expected_trajectory[1]
end_cell_type <- expected_trajectory[length(expected_trajectory)]
```



```{r}
associationTestResult <- associationTest(blase_train, lineages = T, global = F, contrastType = "consecutive")
head(associationTestResult)
nrow(associationTestResult)
```
## Set up BLASE
```{r}
genelist <- blase::get_top_n_genes(associationTestResult, n_genes = 1000, lineage = 1)
res <- blase::find_best_params(blase_train, genelist, split_by = "pseudotime_range", bins_count_range = c(4, 5, 6, 7, 8, 9, 10), gene_count_range = c(10, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200, 220, 240, 260, 280, 300, 320, 340, 360))

blase::plot_find_best_params_results(res)
```

```{r}
blase_data = as.BlaseData(blase_train, n_bins = 7)
blase_data@genes = genelist[1:160]
evaluate_parameters(blase_data, make_plot = TRUE)
blase_train = assign_pseudotime_bins(blase_train, n_bins=7)
```
You can also inspect how the top genes change over each pseudotime bin:

```{r}
evaluate_top_n_genes(blase_data)
```

### View Dataset Following Assignation of bins
```{r}
plotUMAP(blase_train, color_by = "STD.CellType", text_by = "STD.CellType") + ggtitle("Cell Type")
plotUMAP(blase_train, color_by = "slingPseudotime_1") + ggtitle("Slingshot Pseudotime")
plotUMAP(blase_train, color_by = "pseudotime_bin") + ggtitle("BLASE Pseudotime Bin")
```

## Generate "bulk" datasets
In this article we will pseudobulk the Single Cell data into bulk datasets to demonstrate that
BLASE can map a given cluster back to itself.
```{r}
bulks_df = DataFrame(row.names = rownames(counts(blase_test)))
for (type in unique(blase_test$STD.CellType)) {
  bulks_df = cbind(bulks_df, rowSums(normcounts(subset(blase_test, , STD.CellType == type))))
}
colnames(bulks_df) = as.character(unique(blase_test$STD.CellType))
```

## Run BLASE
We will now verify that BLASE can accurately map these "bulk" datasets back to the SC clusters

```{r}
results = c()
for (type in expected_trajectory) {
  print(type)
  results = c(results, map_best_bin(blase_data, type, bulks_df))
}
```

```{r}
results
plot_mapping_result_heatmap(as.list(results)) +
  ggtitle("BLASE")
```

## Comparison With Existing Tools
```{r}
getwd()
source('comparison_functions.R')
blase_train$s = round(runif(ncol(blase_train), 0, 1)) # Simulate 2 samples
```

### SCDC
```{r SCDC}
# SCDC has issues when a cell type is only in one sample (https://github.com/meichendong/SCDC/issues/37)
# See also `table (blase_train$STD.CellType, blase_train$Sample)`
res <- SCDC(blase_train, 'STD.CellType', bulks_df, 's')
print(res$prop.est.mvw)

to_plot <- as.data.frame(res$prop.est.mvw)
to_plot$BulkID <- rownames(to_plot)
to_plot <- melt(to_plot)

ggplot(to_plot, aes(variable, BulkID)) +
  geom_tile(aes(fill = value), colour = "white") +
  geom_text(aes(label = round(value, 2))) +
  scale_fill_gradient(low = "white", high = "red", limits=c(0,1)) +
  scale_y_discrete(limits = expected_trajectory) +
  scale_x_discrete(limits = expected_trajectory) +
  ggtitle("SCDC")
```

### MuSiC
```{r music}
# Music requires at least 2 samples, and all cells represented across all samples
resm <- MUSIC(blase_train, 'STD.CellType', bulks_df, 's')
print(resm$prop.est.mvw)

to_plot <- as.data.frame(resm$Est.prop.weighted)
to_plot$BulkID <- rownames(to_plot)
to_plot <- melt(to_plot)

ggplot(to_plot, aes(variable, BulkID)) +
  geom_tile(aes(fill = value), colour = "white") +
  geom_text(aes(label = round(value, 2))) +
  scale_fill_gradient(low = "white", high = "red", limits=c(0,1)) +
  scale_y_discrete(limits = expected_trajectory) +
  scale_x_discrete(limits = expected_trajectory) +
  ggtitle("MuSiC")


```

### CibersortX

```{r cibersort}
cibersort <- CibersortX(blase_train, 'STD.CellType', bulks_df, N_CORES)
to_plot <- as.data.frame(cibersort)
to_plot <- subset(to_plot, select = -c(P.value, Correlation, RMSE))
to_plot$BulkID <- rownames(to_plot)
to_plot <- melt(to_plot)

ggplot(to_plot, aes(variable, Mixture)) +
  geom_tile(aes(fill = value), colour = "white") +
  geom_text(aes(label = round(value, 2))) +
  scale_fill_gradient(low = "white", high = "red", limits=c(0,1)) +
  scale_y_discrete(limits = expected_trajectory) +
  scale_x_discrete(limits = paste0('c', expected_trajectory)) + 
  ggtitle("CibersortX")
## TODO INCLUDE CONFIDENCE - SHOULD BE CODE FOR THIS IN MCA/ZHANG FILE
```

## Experiment with other parameter selections
```{r}
res <- blase::find_best_params(blase_train, genelist, split_by = "pseudotime_range", bins_count_range = c(4, 5, 6, 7, 8, 9, 10), gene_count_range = c(10, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200, 220, 240, 260, 280, 300, 320, 340, 360))
blase::plot_find_best_params_results(res)
```

### Previous values
```{r}
blase_data = as.BlaseData(blase_train, n_bins = 7)
blase_data@genes = genelist[1:160]
original_results = c()
for (type in expected_trajectory) {
  original_results = c(original_results, map_best_bin(blase_data, type, bulks_df))
}
original_results_plot = plot_mapping_result_heatmap(as.list(original_results))
```

### Genes

#### Fewer Genes
```{r}
blase_data = as.BlaseData(blase_train, n_bins = 7)
blase_data@genes = genelist[1:20]
low_genes_results = c()
for (type in expected_trajectory) {
  low_genes_results = c(low_genes_results, map_best_bin(blase_data, type, bulks_df))
}
low_genes_results_plot = plot_mapping_result_heatmap(as.list(low_genes_results))
```

#### More Genes
```{r}
blase_data = as.BlaseData(blase_train, n_bins = 7)
blase_data@genes = genelist[1:400]
high_genes_results = c()
for (type in expected_trajectory) {
  high_genes_results = c(high_genes_results, map_best_bin(blase_data, type, bulks_df))
}
high_genes_results_plot = plot_mapping_result_heatmap(as.list(high_genes_results))
```

#### Comparison
```{r}
gridExtra::grid.arrange(
  low_genes_results_plot + ggplot2::ggtitle('20 Genes'),
  original_results_plot + ggplot2::ggtitle('160 Genes (Original)'),
  high_genes_results_plot + ggplot2::ggtitle('400 Genes'),
  ncol = 2
)
```
Note that too few genes reduces signal, but too many genes increases noise.

### Bins

### Fewer Bins
```{r}
blase_data = as.BlaseData(blase_train, n_bins = 3)
blase_data@genes = genelist[1:160]
low_bins_results = c()
for (type in expected_trajectory) {
  low_bins_results = c(low_bins_results, map_best_bin(blase_data, type, bulks_df))
}
low_bins_results_plot = plot_mapping_result_heatmap(as.list(low_bins_results))
```
### More Bins
```{r}
blase_data = as.BlaseData(blase_train, n_bins = 20)
blase_data@genes = genelist[1:160]
high_bins_results = c()
for (type in expected_trajectory) {
  high_bins_results = c(high_bins_results, map_best_bin(blase_data, type, bulks_df))
}
high_bins_results_plot = plot_mapping_result_heatmap(as.list(high_bins_results))
```

#### Comparison
```{r}
gridExtra::grid.arrange(
  low_bins_results_plot + ggplot2::ggtitle('3 Bins'),
  original_results_plot + ggplot2::ggtitle('7 Bins (Original)'),
  high_bins_results_plot + ggplot2::ggtitle('20 Bins'),
  ncol = 2
)
```
Too few bins reduces accuracy, too many bins reduces precision as bins get increasingly similar.

### Summary Figure
```{r}
gridExtra::grid.arrange(
  low_genes_results_plot + ggplot2::ggtitle('20 Genes'),
  original_results_plot + ggplot2::ggtitle('160 Genes (Original)'),
  high_genes_results_plot + ggplot2::ggtitle('400 Genes'),
  low_bins_results_plot + ggplot2::ggtitle('3 Bins'),
  original_results_plot + ggplot2::ggtitle('7 Bins (Original)'),
  high_bins_results_plot + ggplot2::ggtitle('20 Bins'),
  ncol = 3
)
```

## Session Info
```{r}
sessionInfo()
```