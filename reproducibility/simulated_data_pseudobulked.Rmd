---
title: "Simulated data pseudobulked"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, results='hide', message=FALSE, warning=FALSE}
library(blase)
library(SingleCellExperiment)
library(tradeSeq)
library(slingshot)
library(scran)
library(scater)
library(BiocParallel)
library(dyngen)
library(bluster)
library(fs)
library(utils)
```

```{r randomseed}
RNGversion("3.5.0")
SEED = 7
set.seed(SEED)
```

In this article, we'll simulate a dataset, and show that BLASE works well with it, 
mapping pseudobulked SC counts to the same SC data. We split the simulated data in 
half and use one half of it as the scRNA-seq, and the other for pseudobulking.

```{r concurrency}
N_CORES = 4
if (ami::using_ci()) {
  N_CORES = 2
}
```

## Get the simulation data
Steps to generate this data are available in [generate-simulated-data-object](articles/generate-simulated-data-object).
```{r generateCounts}
data(processed_simulated_data_SCE, package="blase")
```

Here we'll set up the SCE and preprocess the data ready for trajectory analysis. 
We show the `sim_time` mapped onto it, which shows the true simulated trajectory.

```{r clusterSCE}
data(processed_simulated_data_SCE, package="blase")

gridExtra::grid.arrange(
  plotPCA(processed_simulated_data_SCE, colour_by="label"),
  plotUMAP(processed_simulated_data_SCE, colour_by="label"),
  plotPCA(processed_simulated_data_SCE, colour_by="sim_time"),
  plotUMAP(processed_simulated_data_SCE, colour_by="sim_time"),
  ncol=2
)
```

The start cluster is labeled `4`.
```{r}
START_CLUSTER = 4
```

## Split Datasets

We will now split the dataset so that the test dataset is unseen.

```{r}
processed_simulated_data_SCE$useAsBulk = round(runif(n=ncol(processed_simulated_data_SCE), min=0, max=1)) == 1
bulk_sce = subset(processed_simulated_data_SCE, , useAsBulk==TRUE)
sc_sce = subset(processed_simulated_data_SCE, , useAsBulk==FALSE)
rm(processed_simulated_data_SCE)
```

## SC Trajectory Analysis
Now we'll use slingshot to infer a trajectory, and tradeseq to identify highly variable genes. We will compare the trajectory to the simulated time below.
```{r}
sc_sce
sc_sce <- slingshot(sc_sce, reducedDim = 'UMAP', clusterLabels='label', start.clus=START_CLUSTER)
gridExtra::grid.arrange(
  plotPCA(sc_sce, colour_by="sim_time"),
  #plotPCA(sc_sce, colour_by="slingPseudotime_1"),
  plotUMAP(sc_sce, colour_by="sim_time"),
  #plotUMAP(sc_sce, colour_by="slingPseudotime_1"),
  plotPCA(sc_sce, colour_by="label"),
  plotUMAP(sc_sce, colour_by="label"),
  ncol=2
)

```

```{r, results='hide', message=FALSE, warning=FALSE}
sc_sce <- fitGAM(sc_sce, parallel=T, BPPARAM=MulticoreParam(N_CORES), nknots=4)
associationTestResult <- associationTest(sc_sce, lineages=T, global=F, contrastType="consecutive")
```

## Analyse with BLASE

We start by tuning the parameters for BLASE. See the [vignette](articles/assign-bulk-to-pseudotime.html) for more details.

```{r}
genelist = blase::get_top_n_genes(associationTestResult, n_genes = 200, lineage = 1)
res = find_best_params(sc_sce,
                       genelist,
                       split_by="pseudotime_range",
                       pseudotime_slot="slingPseudotime_1",
                       bins_count_range = seq.int(3, 10, 1),
                       gene_count_range = seq.int(3, 60, 3))
plot_find_best_params_results(res)
```
```{r}
genes = 30
bins = 5
blase_data = as.blaseData(sc_sce, pseudotime_slot="slingPseudotime_1", n_bins=bins, split_by="pseudotime_range")
genes(blase_data) = genelist[1:genes]
evaluate_parameters(blase_data, make_plot = TRUE)
```
## Prepare Bulk

Here we set up the same trajectory with the bulk dataset, and split it into separate "bulk" counts.

```{r}
bulk_sce

bulk_sce <- slingshot(bulk_sce, reducedDim = 'UMAP', clusterLabels='label', start.clus=START_CLUSTER)

gridExtra::grid.arrange(
  plotPCA(bulk_sce, colour_by="sim_time"),
  plotPCA(bulk_sce, colour_by="slingPseudotime_1"),
  plotUMAP(bulk_sce, colour_by="sim_time"),
  plotUMAP(bulk_sce, colour_by="slingPseudotime_1"),
  ncol=2
)

bulk_sce = assign_pseudotime_bins(bulk_sce, split_by='pseudotime_range', n_bins = bins, pseudotime_slot="slingPseudotime_1")
bulk_sce$replicate = round(runif(n=ncol(bulk_sce), min=1, max=2))
bulkified_bins = blase::get_bins_as_bulk(bulk_sce, min_cells_for_bulk = 20)
```

## Map the bulk to the single cell

Now we'll map the bulk onto the single cell data with BLASE. We can see the bins and mapping results below. Most are confidently mapped correctly, and 4 are not confidently mapped, but still correctly.

```{r}
mapping_results = c()
for (bulkname in colnames(bulkified_bins)) {
  res = map_best_bin(blase_data, bulkname, bulkified_bins)
  mapping_results = c(mapping_results, res)
  print(res)
}

sc_sce = assign_pseudotime_bins(sc_sce, split_by = 'pseudotime_range', n_bins = bins, pseudotime_slot='slingPseudotime_1')
gridExtra::grid.arrange(
  plotUMAP(bulk_sce, colour_by="sim_time"),
  plotUMAP(bulk_sce, colour_by="slingPseudotime_1"),
  plotUMAP(sc_sce, colour="pseudotime_bin"),
  ncol=3
)
blase::plot_mapping_result_heatmap(rev(mapping_results))
```

Now we can look at the population proportions of the bins.

Each row below shows the following four plots:
1. The **SC** label proportions for a given bin
2. The **bulk** label proportions for a given bin
3. Mapping correlations for replicate 1 of a given bin
4. Mapping correlations for replicate 2 of a given bin

```{r}
gridExtra::grid.arrange(
  blase::plot_bin_population(sc_sce, 1, group_by_slot="label") + ggtitle("SC Labels in Bin 1"),
  blase::plot_bin_population(bulk_sce, 1, group_by_slot="label") + ggtitle("Bulk Labels in Bin 1"),
  blase::plot_mapping_result_corr(mapping_results[[1]]) + ggtitle("Mapping correlations for bin 1 rep. 1"),
  blase::plot_mapping_result_corr(mapping_results[[2]]) + ggtitle("Mapping correlations for bin 1 rep. 2"),
  ncol=2
)
gridExtra::grid.arrange(
  blase::plot_bin_population(sc_sce, 2, group_by_slot="label") + ggtitle("SC Labels in Bin 2"),
  blase::plot_bin_population(bulk_sce, 2, group_by_slot="label") + ggtitle("Bulk Labels in Bin 2"),
  blase::plot_mapping_result_corr(mapping_results[[3]]) + ggtitle("Mapping correlations for bin 2 rep. 1"),
  blase::plot_mapping_result_corr(mapping_results[[4]]) + ggtitle("Mapping correlations for bin 2 rep. 2"),
  ncol=2
)
gridExtra::grid.arrange(
  blase::plot_bin_population(sc_sce, 3, group_by_slot="label") + ggtitle("SC Labels in Bin 3"),
  blase::plot_bin_population(bulk_sce, 3, group_by_slot="label") + ggtitle("Bulk Labels in Bin 3"),
  blase::plot_mapping_result_corr(mapping_results[[5]]) + ggtitle("Mapping correlations for bin 3 rep. 1"),
  blase::plot_mapping_result_corr(mapping_results[[6]]) + ggtitle("Mapping correlations for bin 3 rep. 2"),
  ncol=2
)
gridExtra::grid.arrange(
  blase::plot_bin_population(sc_sce, 4, group_by_slot="label") + ggtitle("SC Labels in Bin 4"),
  blase::plot_bin_population(bulk_sce, 4, group_by_slot="label") + ggtitle("Bulk Labels in Bin 4"),
  blase::plot_mapping_result_corr(mapping_results[[7]]) + ggtitle("Mapping correlations for bin 4 rep. 1"),
  blase::plot_mapping_result_corr(mapping_results[[8]]) + ggtitle("Mapping correlations for bin 4 rep. 2"),
  ncol=2
)
gridExtra::grid.arrange(
  blase::plot_bin_population(sc_sce, 5, group_by_slot="label") + ggtitle("SC Labels in Bin 5"),
  blase::plot_bin_population(bulk_sce, 5, group_by_slot="label") + ggtitle("Bulk Labels in Bin 5"),
  blase::plot_mapping_result_corr(mapping_results[[9]]) + ggtitle("Mapping correlations for bin 5 rep. 1"),
  blase::plot_mapping_result_corr(mapping_results[[10]]) + ggtitle("Mapping correlations for bin 5 rep. 2"),
  ncol=2
)

```

## Test comparison tools
```{r}
getwd()
source('comparison_functions.R')

sample_order = c(
  "bin_1_rep_1",
  "bin_1_rep_2",
  "bin_2_rep_1",
  "bin_2_rep_2",
  "bin_3_rep_1",
  "bin_3_rep_2",
  "bin_4_rep_1",
  "bin_4_rep_2",
  "bin_5_rep_1",
  "bin_5_rep_2"
)

sc_sce$s = round(runif(ncol(sc_sce), 0, 1)) # Simulate 2 samples
```

### SCDC
```{r}
scdc_results = SCDC(sc_sce, 'pseudotime_bin', bulkified_bins, 's')
print(scdc_results$prop.est.mvw)

to_plot <- as.data.frame(scdc_results$prop.est.mvw)
to_plot$BulkID <- rownames(to_plot)
to_plot <- melt(to_plot)

scdc_results_plot = ggplot(to_plot, aes(variable, BulkID)) +
  geom_tile(aes(fill = value), colour = "white") +
  scale_fill_gradient(low = "white", high = "red", limits=c(0,1)) +
  scale_y_discrete(limits = sample_order) +
  scale_x_discrete(limits = seq_len(5)) +
  ggtitle("SCDC")
scdc_results_plot + geom_text(aes(label = round(value, 2)))
```
### MuSiC
```{r}
# Music requires at least 2 samples, and all cells represented across all samples
music_results <- MUSIC(sc_sce, 'pseudotime_bin', bulkified_bins, 's')
print(music_results$prop.est.mvw)

to_plot <- as.data.frame(music_results$Est.prop.weighted)
to_plot$BulkID <- rownames(to_plot)
to_plot <- melt(to_plot)

music_results_plot = ggplot(to_plot, aes(variable, BulkID)) +
  geom_tile(aes(fill = value), colour = "white") +
  scale_fill_gradient(low = "white", high = "red", limits=c(0,1)) +
  scale_y_discrete(limits = sample_order) +
  scale_x_discrete(limits = seq_len(5)) +
  ggtitle("MuSiC")
music_results_plot + geom_text(aes(label = round(value, 2)))
```

### CibersortX
Does not complete, code provided for completeness.
```{r, eval=FALSE cibersort}
cibersort <- CibersortX(sc_sce, 'pseudotime_bin', bulkified_bins, N_CORES)
to_plot <- as.data.frame(cibersort)
to_plot <- subset(to_plot, select = -c(P.value, Correlation, RMSE))
to_plot$BulkID <- rownames(to_plot)
to_plot <- melt(to_plot)

ggplot(to_plot, aes(variable, Mixture)) +
  geom_tile(aes(fill = value), colour = "white") +
  geom_text(aes(label = round(value, 2))) +
  scale_fill_gradient(low = "white", high = "red", limits=c(0,1)) +
  scale_y_discrete(limits = expected_trajectory) +
  scale_x_discrete(limits = paste0('c', seq_len(5))) + 
  ggtitle("CibersortX")
```

## Session Info
```{r sessionInfo}
sessionInfo()
```
