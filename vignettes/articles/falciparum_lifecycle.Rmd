---
title: "falciparum_lifecycle"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(readxl)
library(scran)
library(slingshot)
library(tradeSeq)
library(BiocParallel)
library(fs)
library(atgnat)
```

In this article we will use BLASE to map Plasmodium Falciparum microarray data of the asexual lifecycle ([Painter et al. 2018](https://doi.org/10.1038/s41467-018-04966-3), 3d7 strain) onto the Malaria Cell Atlas ([Howick et al. 2019](https://doi.org/10.1126/science.aaw2619), 7G8 & NF54 strains)  to try and annotate it over a 48 hour period. 

```{r getData}
root_dir = tools::R_user_dir("BLASE", "data")
article_dir = path(root_dir, "3d7_lifecycle")
if (!dir.exists(article_dir)) {
  dir.create(article_dir)
}
article_dir

bulk_path = path(article_dir, "3d7_bulk_timepoints", ext="xlsx")
if (!file.exists(bulk_path)) {
  download.file('https://static-content.springer.com/esm/art%3A10.1038%2Fs41467-018-04966-3/MediaObjects/41467_2018_4966_MOESM4_ESM.xlsx', bulk_path)
}else {
  print(paste("Using cached", bulk_path))
}

mca_path = path(article_dir, "MCA", ext="zip")
if (!file.exists(mca_path)) {
  download.file('https://www.malariacellatlas.org/downloads/pf.zip', mca_path)
  unzip(mca_path, exdir = paste0(article_dir, '/MCA'))
}else {
  print(paste("Using cached", mca_path))
}

bulk = as.data.frame(read_excel(bulk_path, sheet = "Estimated Total Abundance"))
rownames(bulk) = bulk$`Gene ID`
rownames(bulk) = gsub(x=rownames(bulk), pattern="_", replacement="-", fixed=TRUE)
bulk = bulk[7:nrow(bulk),]
bulk = subset(bulk, , -c(`Gene ID`, `Annotation`, `Peak Time (hpi)`, `p-value`))

mca_counts_path = path(article_dir, "MCA", "pf-ch10x-raw", ext="csv")
sc_readcounts = read.csv(mca_counts_path, row.names=1)

mca_annotation_path = path(article_dir, "MCA", "pf-ch10x-data", ext="csv")
sc_annotations = read.csv(mca_annotation_path, row.names=1)
```
## Prepare SC
```{r}
rownames(sc_annotations) = gsub(x = rownames(sc_annotations), pattern="-", replacement=".", fixed=TRUE)
sc_annotations

# Combine all genes with multiple transcripts
genes_to_fix = rownames(sc_readcounts)[!(rownames(sc_readcounts) %in% sub(x=rownames(sc_readcounts), pattern="\\.[0-9]", replacement=""))]
genes_to_fix = unique(sub(x=genes_to_fix, pattern="\\.[0-9]", replacement=""))
print(paste("Fixing this many genes:", length(genes_to_fix)))

# TODO: Slow on windows, see if there's a way to speed up
for (gene in genes_to_fix) {
  print(gene)
  targetRowNames = rownames(sc_readcounts)[grep(x=rownames(sc_readcounts), pattern=gene)]
  counts = colSums(sc_readcounts[targetRowNames,])
  counts = t(data.frame(counts=colSums(sc_readcounts[targetRowNames,])))
  rownames(counts) = c(gene)
  
  sc_readcounts <- sc_readcounts[ !(rownames(sc_readcounts) %in% targetRowNames), ]

  sc_readcounts = rbind(sc_readcounts, counts)
}

genes_to_fix = rownames(sc_readcounts)[!(rownames(sc_readcounts) %in% sub(x=rownames(sc_readcounts), pattern="\\.[0-9]", replacement=""))]
genes_to_fix = unique(sub(x=genes_to_fix, pattern="\\.[0-9]", replacement=""))
print(paste("Remaining genes with dups:", genes_to_fix))

sce = SingleCellExperiment(assays=list(counts=as.matrix(sc_readcounts)), colData=sc_annotations)
rownames(sce) = sub(x=rownames(sce), pattern="\\.[0-9]", replacement="")

rm(sc_annotations, sc_readcounts)
gc()

sce = subset(sce, , STAGE_LR != 'gametocyte')

sce <- computeSumFactors(sce)
sce <- logNormCounts(sce)
normcounts(sce) <- exp(logcounts(sce))

reducedDim(sce, "PCA") = as.matrix(cbind(sce@colData["PC_1"], sce@colData["PC_2"],sce@colData["PC_3"]))
# better separation in the 2nd and 3rd dimension for just asexual stages
reducedDim(sce, "UMAP") = as.matrix(cbind(sce@colData["UMAP_2"], sce@colData["UMAP_3"]))

sce <- slingshot(sce, reducedDim = 'UMAP', clusterLabels="STAGE_LR", start.clus="ring")

gridExtra::grid.arrange(
  plotPCA(sce, colour_by="STAGE_LR"),
  plotUMAP(sce, colour_by="STAGE_LR"),
  plotPCA(sce, colour_by="DAY"),
  plotUMAP(sce, colour_by="DAY"),
  plotPCA(sce, colour_by="STRAIN"),
  plotUMAP(sce, colour_by="STRAIN"),
  plotPCA(sce, colour_by="slingPseudotime_1"),
  plotUMAP(sce, colour_by="slingPseudotime_1"),
  ncol=2
)

```

```{r}
# evaluateK(sce, k=6:8, parallel=T, BPPARAM=MulticoreParam(2))
```

```{r}
sce <- fitGAM(sce, parallel=T, BPPARAM=MulticoreParam(5), nknots=7)
associationTestResult <- associationTest(sce, lineages=T, global=F, contrastType="consecutive")
```

## Compare Gene Lists
```{r}
waves = get_waves(sce, "slingPseudotime_1", n_cores=4)
gene_selection_matrix(sce, waves, n_cores=4)
```

## Get Fourier Genes
```{r}
fourier_power_genes = select_genes_by_fourier_method(sce, waves, n_groups=100, top_n_per_group=2)
gene_selection_matrix(sce, waves, genes=rownames(fourier_power_genes), target_matrix_size=nrow(fourier_power_genes))
```

## Prepare BLASE
```{r}
genelist = atgnat::get_top_n_genes(associationTestResult, n_genes = 500, lineage = 1)
gene_selection_matrix(sce, waves, genes=genelist[0:300], target_matrix_size=300)
```

```{r}
res = find_best_params(sce,
                       genelist,
                       split_by="pseudotime_range",
                       pseudotime_slot="slingPseudotime_1",
                       bins_count_range = seq.int(10, 14, 1),
                       gene_count_range = seq.int(12, 192, 3))
plot_find_best_params_results(res)
```
```{r}
res2 = find_best_params(sce,
                       genelist,
                       split_by="pseudotime_range",
                       pseudotime_slot="slingPseudotime_1",
                       bins_count_range = 12,
                       gene_count_range = seq.int(12, 192, 3))
plot_find_best_params_results(res2)
```

### Using TradeSeq genes
```{r}
genes = 300
bins = 12
sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=bins, split_by="pseudotime_range")
plotUMAP(sce, color="pseudotime_bin")
gridExtra::grid.arrange(
  plotUMAP(sce, color="STAGE_LR"),
  plotUMAP(sce, color="pseudotime_bin"),
  ncol=2
)
```


```{r}
atgnatData = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=bins, split_by="pseudotime_range")
atgnatData@genes = genelist[1:genes]
evaluate_parameters(atgnatData, make_plot = TRUE)
```

```{r}
## Map Bulk data onto Single Cell

mapping_results = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(atgnatData, bulkname, bulk)
  mapping_results = c(mapping_results, res)
}

atgnat::plot_mapping_result_heatmap(rev(mapping_results), annotate = TRUE)
ggplot2::ggsave(paste0("blase_heatmap_tradeseq_", bins, "_bins_", genes, "_genes.png"), path="/Users/andrewmccluskey/code/PhD")
```

### Using Fourier Genes
```{r}
atgnatData = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=bins, split_by="pseudotime_range")
atgnatData@genes = rownames(fourier_power_genes)
evaluate_parameters(atgnatData, make_plot = TRUE)
```

```{r}
## Map Bulk data onto Single Cell

mapping_results_fourier = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(atgnatData, bulkname, bulk)
  mapping_results_fourier = c(mapping_results_fourier, res)
}

atgnat::plot_mapping_result_heatmap(rev(mapping_results_fourier), annotate = TRUE)
ggplot2::ggsave(paste0("blase_heatmap_fourierpower_", bins, "_bins_", genes, "_genes.png"), path="/Users/andrewmccluskey/code/PhD")
```
## Analysing Accuracy

The Bulk paper describes the following timepoints HPI matching to lifecycle stages, in figure 1:
* 5-15: Ring
* 15-34: Troph
* 34-40: Schizont
* 40-45: Merozoites
```{r}
expected_rings_hpi = 5:15
expected_trophs_hpi = 16:34
expected_schizont_hpi = 35:42
```


Below, we can see how out bins are aligned with lifecycle stages
```{r}
table(sce@colData[c("STAGE_LR", "pseudotime_bin")])
called_ring_bins = sort(unique(sce@colData[sce@colData[["STAGE_LR"]] == "ring",][["pseudotime_bin"]]))
called_troph_bins = sort(unique(sce@colData[sce@colData[["STAGE_LR"]] == "trophozoite",][["pseudotime_bin"]]))
called_schizont_bins = sort(unique(sce@colData[sce@colData[["STAGE_LR"]] == "schizont",][["pseudotime_bin"]]))
```
Now we can check the accuracy of these techniques, according to prior knowledge.

```{r}
analyse_mapping_results = function(mapping_results) {
  results = data.frame()
  for (bulk_sample in mapping_results) {
    timepoint = as.numeric(gsub(x=bulk_sample@bulk_name, pattern=" hpi", replacement=""))
    
    expected_stage_from_hpi = "NA"
    if (timepoint %in% expected_rings_hpi) {
      expected_stage_from_hpi = "Rings"
    } else if (timepoint %in% expected_trophs_hpi) {
      expected_stage_from_hpi = "Trophs"
    } else if (timepoint %in% expected_schizont_hpi) {
      expected_stage_from_hpi = "Schizonts"
    } else {
      next
    }
    
    blase_predicted_stage = ""
    if (bulk_sample@best_bin %in% called_ring_bins) {
      blase_predicted_stage = paste(blase_predicted_stage,"Rings")
    }
    if (bulk_sample@best_bin %in% called_troph_bins) {
      blase_predicted_stage = paste(blase_predicted_stage,"Trophs")
    }
    if (bulk_sample@best_bin %in% called_schizont_bins) {
      blase_predicted_stage = paste(blase_predicted_stage,"Schizonts")
    }
    
    results = rbind(results, data.frame(
      timepoint=timepoint, 
      expected_stage_from_hpi=expected_stage_from_hpi, 
      blase_predicted_stage=blase_predicted_stage,
      bin_call=bulk_sample@best_bin,
      confident_call=bulk_sample@confident_mapping))
  
  }
  return(results)
}

describe_results = function(result_set) {
  # Wrong because %in% is just checking the whole list, but we want the sublist
  incorrect = nrow(result_set[!mapply(`grepl`, result_set$expected_stage_from_hpi, result_set$blase_predicted_stage),])
  confident = nrow(result_set[result_set$confident_call,])
  incorrect_confident = nrow(result_set[!mapply(`grepl`, result_set$expected_stage_from_hpi, result_set$blase_predicted_stage) & result_set$confident_call,])
  
  return(paste(
    paste(incorrect, "wrong out of", nrow(result_set)),
    paste(incorrect_confident, "confident calls wrong out of", confident),
    sep=", "
  ))
}

```

```{r}
results_tradeseq = analyse_mapping_results(mapping_results)
results_fourier = analyse_mapping_results(mapping_results_fourier)

print(paste("Tradeseq:", describe_results(results_tradeseq)))
print(paste("Fourier:", describe_results(results_fourier)))
```

