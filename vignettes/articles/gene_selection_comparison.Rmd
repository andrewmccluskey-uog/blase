---
title: "Comparing Gene Selection Methods"
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
```

```{r setup, results='hide', message=FALSE, warning=FALSE}
library(readxl)
library(scran)
library(slingshot)
library(tradeSeq)
library(BiocParallel)
library(UpSetR)
library(emdist)
library(scater)
library(fs)
library(utils)
library(metR)
library(blase)
```

```{r randomseed}
RNGversion("3.5.0")
SEED <- 7
set.seed(SEED)
```

```{r concurrency}
N_CORES <- 4
if (ami::using_ci()) {
    N_CORES <- 2
}
```

In this article we will look at different methods for gene selection,
using the MCA's *Plasmodium berghei* Data [Howick et al,
2019](https://dx.doi.org/10.1126/science.aaw2619), and bulk RNA seq of
the lifecycle stages [Otto et al,
2004](https://doi.org/10.1186/s12915-014-0086-0).

We will investigate in detail the 'power' method for gene selection
described in [Bozdech et al.
2003](https://doi.org/10.1371/journal.pbio.0000005)

## Load Data

```{r getData}
root_dir <- tools::R_user_dir("BLASE", "data")

article_dir <- path(root_dir, "gene_selection_comparison")
if (!dir.exists(article_dir)) {
    dir.create(article_dir, recursive = TRUE)
}

bulk_path <- path(article_dir, "otto_pb_bulk_timepoints", ext = "xlsx")
if (!file.exists(bulk_path)) {
    download.file("https://static-content.springer.com/esm/art%3A10.1186%2Fs12915-014-0086-0/MediaObjects/12915_2014_86_MOESM9_ESM.xlsx", bulk_path)
} else {
    print("Using cached")
}

bulk <- as.data.frame(read_excel(bulk_path, range = "FPKM PbA !A4:L5024"))
rownames(bulk) <- bulk$`Gene Models (IDs)`
rownames(bulk) <- gsub(x = rownames(bulk), pattern = "_", replacement = "-", fixed = TRUE)
bulk <- subset(bulk, , -c(`Gene Models (IDs)`))
rownames(bulk) <- paste0(rownames(bulk), "0")
```

```{r}
data(processed_MCA_PB_SCE, package = "blase")

# Remove unshared genes from bulk and sc
bulk <- bulk[rownames(bulk) %in% rownames(processed_MCA_PB_SCE), ]
processed_MCA_PB_SCE <- processed_MCA_PB_SCE[rownames(processed_MCA_PB_SCE) %in% rownames(bulk), ]

gridExtra::grid.arrange(
    plotPCA(processed_MCA_PB_SCE, colour_by = "STAGE_LR"),
    plotUMAP(processed_MCA_PB_SCE, colour_by = "STAGE_LR"),
    plotPCA(processed_MCA_PB_SCE, colour_by = "slingPseudotime_1"),
    plotUMAP(processed_MCA_PB_SCE, colour_by = "slingPseudotime_1"),
    plotPCA(processed_MCA_PB_SCE, colour_by = "pseudotime_bin"),
    plotUMAP(processed_MCA_PB_SCE, colour_by = "pseudotime_bin"),
    ncol = 2
)
```

## Using TradeSeq

First, we'll use tradeSeq to find the genes that Tradeseq thinks are
variable over pseudotime.

```{r}
associationTestResult <- associationTest(processed_MCA_PB_SCE, lineages = T, global = F, contrastType = "consecutive")
table(processed_MCA_PB_SCE$pseudotime_bin)
plotUMAP(processed_MCA_PB_SCE, colour_by = "pseudotime_bin")
```

```{r}
genelist <- blase::get_top_n_genes(associationTestResult, n_genes = 200, lineage = 1)

res <- find_best_params(processed_MCA_PB_SCE,
    genelist,
    split_by = "pseudotime_range",
    pseudotime_slot = "slingPseudotime_1",
    bins_count_range = seq.int(8, 16, 2),
    gene_count_range = seq.int(20, 180, 3)
)

x <- as.BlaseData(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = 14, split_by = "pseudotime_range")

tradeseq_tuning <- plot_find_best_params_results(res)
```

```{r}
BUCKETS_COUNT <- 12
GENES_TO_USE_COUNT <- 120
x <- as.BlaseData(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")
x@genes <- genelist[1:GENES_TO_USE_COUNT]

genes_tradeseq <- x@genes

processed_MCA_PB_SCE <- assign_pseudotime_bins(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")

plotUMAP(processed_MCA_PB_SCE, colour = "pseudotime_bin")

mapping_results <- c()
for (bulkname in colnames(bulk)) {
    res <- map_best_bin(x, bulkname, bulk)
    mapping_results <- c(mapping_results, res)
    print(res)
}

tradeseq_heat <- blase::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0("TradeSeq (", GENES_TO_USE_COUNT, ")"))
tradeseq_heat
```

## Using marker genes

Here we will simply select the top n marker genes for our lifecycle
stage annotations.

```{r}
markers <- scoreMarkers(processed_MCA_PB_SCE, lfc = 1, groups = processed_MCA_PB_SCE$STAGE_LR)

top_n_markers_per_group <- 40
genes <- DataFrame()
for (group in names(markers)) {
    group_markers <- markers[[group]]
    top_genes <- group_markers[order(-group_markers$mean.logFC.cohen), ][0:top_n_markers_per_group, ]
    top_genes <- top_genes[0:top_n_markers_per_group, ]
    top_genes
    top_genes$group <- group
    genes <- rbind(genes, top_genes)
}

genes <- DataFrame(genes$mean.logFC.cohen, genes$group)
genelist <- rownames(genes)
res <- find_best_params(processed_MCA_PB_SCE,
    genelist,
    split_by = "pseudotime_range",
    pseudotime_slot = "slingPseudotime_1",
    bins_count_range = c(12),
    gene_count_range = c(120)
)
markergenes_tuning <- plot_find_best_params_results(res)
```

```{r}
BUCKETS_COUNT <- 12
GENES_TO_USE_COUNT <- 120
x <- as.BlaseData(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")
x@genes <- genelist[1:GENES_TO_USE_COUNT]
genes_markergenes <- x@genes

processed_MCA_PB_SCE <- assign_pseudotime_bins(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")

mapping_results <- c()
for (bulkname in colnames(bulk)) {
    res <- map_best_bin(x, bulkname, bulk)
    mapping_results <- c(mapping_results, res)
    print(res)
}

markergenes_heat <- blase::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0("Marker Genes (", GENES_TO_USE_COUNT, ")"))
markergenes_heat
```

## Pseudotime bin marker genes

Here we select the marker genes for each pseudotime bin.

```{r}
processed_MCA_PB_SCE <- assign_pseudotime_bins(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = 12, split_by = "pseudotime_range")

markers <- scoreMarkers(processed_MCA_PB_SCE, lfc = 1, groups = processed_MCA_PB_SCE$pseudotime_bin)

top_n_markers_per_group <- 10
genes <- DataFrame()
for (group in names(markers)) {
    group_markers <- markers[[group]]
    top_genes <- group_markers[order(-group_markers$mean.logFC.cohen), ][0:top_n_markers_per_group, ]
    top_genes <- top_genes[0:top_n_markers_per_group, ]
    top_genes
    top_genes$group <- group
    genes <- rbind(genes, top_genes)
}

genes <- DataFrame(genes$mean.logFC.cohen, genes$group)
genelist <- rownames(genes)

res <- find_best_params(processed_MCA_PB_SCE,
    genelist,
    split_by = "pseudotime_range",
    pseudotime_slot = "slingPseudotime_1",
    bins_count_range = c(12),
    gene_count_range = c(120)
)
markergenes_by_bin_tuning <- plot_find_best_params_results(res)
```

```{r}
BUCKETS_COUNT <- 12
GENES_TO_USE_COUNT <- 120
x <- as.BlaseData(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")
x@genes <- genelist[1:GENES_TO_USE_COUNT]

genes_markergenes_by_bin <- x@genes

processed_MCA_PB_SCE <- assign_pseudotime_bins(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")

mapping_results <- c()
for (bulkname in colnames(bulk)) {
    res <- map_best_bin(x, bulkname, bulk)
    mapping_results <- c(mapping_results, res)
    print(res)
}

markergenes_by_bin_heat <- blase::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0("Marker Genes by bin (", GENES_TO_USE_COUNT, ")"))
markergenes_by_bin_heat
```

## Using Bozdech Fourier Method

```{r}
processed_MCA_PB_SCE <- assign_pseudotime_bins(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = 12, split_by = "pseudotime_range")

counts <- normcounts(processed_MCA_PB_SCE)[, order(processed_MCA_PB_SCE$slingPseudotime_1)]
waves <- as.data.frame(FitWave(as.matrix(counts["PBANKA-0831000", ]), 0:20))
waves$gene <- rownames(waves)

ggplot2::ggplot(waves, ggplot2::aes(phase, r2, color = amplitude)) +
    ggplot2::geom_point()
ggplot2::ggplot(waves, ggplot2::aes(phase, amplitude, color = r2)) +
    ggplot2::geom_point()
ggplot2::ggplot(waves, ggplot2::aes(phase, amplitude, color = k)) +
    ggplot2::geom_point()

target_to_plot <- "PBANKA-0831000"

toplot <- as.data.frame(counts[target_to_plot, order(processed_MCA_PB_SCE$slingPseudotime_1)])
toplot$pdt <- processed_MCA_PB_SCE$slingPseudotime_1[order(processed_MCA_PB_SCE$slingPseudotime_1)]
colnames(toplot)[1] <- "count"

# I'm pretty sure the x value for buildwave is wrong here
toplot$wave1 <- BuildWave(seq(from = 0, to = max(processed_MCA_PB_SCE$slingPseudotime_1), length.out = nrow(toplot)), wave = FitWave(as.matrix(counts[target_to_plot, ]), 1))
toplot$wave1and2 <- BuildWave(seq(from = 0, to = max(processed_MCA_PB_SCE$slingPseudotime_1), length.out = nrow(toplot)), wave = FitWave(as.matrix(counts[target_to_plot, ]), 1))
toplot$wave1to3 <- BuildWave(seq(from = 0, to = max(processed_MCA_PB_SCE$slingPseudotime_1), length.out = nrow(toplot)), wave = FitWave(as.matrix(counts[target_to_plot, ]), 1:3))
toplot$wave1toten <- BuildWave(seq(from = 0, to = max(processed_MCA_PB_SCE$slingPseudotime_1), length.out = nrow(toplot)), wave = FitWave(as.matrix(counts[target_to_plot, ]), 1:10))

ggplot2::ggplot(toplot, ggplot2::aes(pdt, count)) +
    ggplot2::geom_line() +
    ggplot2::geom_line(ggplot2::aes(pdt, wave1, color = "wave1")) +
    ggplot2::geom_line(ggplot2::aes(pdt, wave1and2, color = "wave1to2")) +
    ggplot2::geom_line(ggplot2::aes(pdt, wave1to3, color = "wave1to3")) +
    ggplot2::geom_line(ggplot2::aes(pdt, wave1toten, color = "wave1toten")) +
    ggplot2::ggtitle(target_to_plot)

ggplot2::ggplot(toplot, ggplot2::aes(pdt, wave1)) +
    ggplot2::geom_line() +
    ggplot2::ggtitle(target_to_plot)
```

```{r}
waves <- get_waves(processed_MCA_PB_SCE, n_cores = N_CORES)

ggplot2::ggplot(waves, ggplot2::aes(phase, r2, color = amplitude)) +
    ggplot2::geom_point()
ggplot2::ggplot(waves, ggplot2::aes(phase, amplitude, color = r2)) +
    ggplot2::geom_point()
ggplot2::ggplot(waves, ggplot2::aes(phase, power, color = r2)) +
    ggplot2::geom_point()
ggplot2::ggplot(waves, ggplot2::aes(phase, power, color = amplitude)) +
    ggplot2::geom_point()
```

### Phase Ordering genes

Here we've plotted the genes and cells ordered by their peak phase and
pseudotime respectively. This functionality is available as a part of
BLASE, please see the `gene_selection_matrix()` function.

```{r}
gene_selection_matrix(processed_MCA_PB_SCE, waves, target_matrix_size = 1000, n_cores = N_CORES)
```

Here we set the number of buckets and genes to use:

```{r}
BUCKETS_COUNT <- 12
GENES_TO_USE_COUNT <- 120
```

### Top r2 waves

```{r}
top_r2_waves <- select_genes_by_fourier_method(processed_MCA_PB_SCE, waves, n_genes = GENES_TO_USE_COUNT, method = "r2", force_spread_selection = FALSE)

ggplot2::ggplot(top_r2_waves, ggplot2::aes(phase, amplitude, color = r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(processed_MCA_PB_SCE$slingPseudotime_1))) +
    ggplot2::ggtitle("top_r2_waves")

top_genes_fourier_top_r2 <- rownames(top_r2_waves)

x <- as.BlaseData(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")
x@genes <- top_genes_fourier_top_r2

processed_MCA_PB_SCE <- assign_pseudotime_bins(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")

mapping_results <- c()
for (bulkname in colnames(bulk)) {
    res <- map_best_bin(x, bulkname, bulk)
    mapping_results <- c(mapping_results, res)
    print(res)
}

fourier_top_r2_heat <- blase::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0("fourier_top_r2 (", GENES_TO_USE_COUNT, ")"))
fourier_top_r2_heat
```

### Top r2 waves with spread

```{r}
top_r2_waves_spread <- select_genes_by_fourier_method(processed_MCA_PB_SCE, waves, n_groups = GENES_TO_USE_COUNT, method = "r2", force_spread_selection = TRUE)

ggplot2::ggplot(top_r2_waves_spread, ggplot2::aes(phase, amplitude, color = r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(processed_MCA_PB_SCE$slingPseudotime_1))) +
    ggplot2::ggtitle("top_r2_waves_spread")

top_genes_fourier_top_r2_spread <- rownames(top_r2_waves_spread)

x <- as.BlaseData(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")
x@genes <- top_genes_fourier_top_r2_spread

processed_MCA_PB_SCE <- assign_pseudotime_bins(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")

mapping_results <- c()
for (bulkname in colnames(bulk)) {
    res <- map_best_bin(x, bulkname, bulk)
    mapping_results <- c(mapping_results, res)
    print(res)
}

fourier_top_r2_spread_heat <- blase::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0("fourier_top_r2_spread (", GENES_TO_USE_COUNT, ")"))
fourier_top_r2_spread_heat
```

### Top amp waves

```{r}
top_amp_waves <- waves[order(-waves$amplitude), ][0:GENES_TO_USE_COUNT, ]
top_amp_waves <- select_genes_by_fourier_method(processed_MCA_PB_SCE, waves, n_genes = GENES_TO_USE_COUNT, method = "amplitude", force_spread_selection = FALSE)

ggplot2::ggplot(top_amp_waves, ggplot2::aes(phase, amplitude, color = r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(processed_MCA_PB_SCE$slingPseudotime_1))) +
    ggplot2::ggtitle("top_amp_waves")

top_genes_fourier_top_amp <- rownames(top_amp_waves)

x <- as.BlaseData(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")
x@genes <- top_genes_fourier_top_amp

processed_MCA_PB_SCE <- assign_pseudotime_bins(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")

mapping_results <- c()
for (bulkname in colnames(bulk)) {
    res <- map_best_bin(x, bulkname, bulk)
    mapping_results <- c(mapping_results, res)
    print(res)
}

fourier_top_amp_heat <- blase::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0("fourier_top_amp (", GENES_TO_USE_COUNT, ")"))
fourier_top_amp_heat
```

### Top Amp Waves with spread

```{r}
top_amp_waves_spread <- select_genes_by_fourier_method(processed_MCA_PB_SCE, waves, n_groups = GENES_TO_USE_COUNT, method = "amplitude", force_spread_selection = TRUE)

ggplot2::ggplot(top_amp_waves_spread, ggplot2::aes(phase, amplitude, color = r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(processed_MCA_PB_SCE$slingPseudotime_1))) +
    ggplot2::ggtitle("top_amp_waves_spread")

top_genes_fourier_top_amp_spread <- rownames(top_amp_waves_spread)

x <- as.BlaseData(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")
x@genes <- top_genes_fourier_top_amp_spread

processed_MCA_PB_SCE <- assign_pseudotime_bins(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")

mapping_results <- c()
for (bulkname in colnames(bulk)) {
    res <- map_best_bin(x, bulkname, bulk)
    mapping_results <- c(mapping_results, res)
    print(res)
}

fourier_top_amp_spread_heat <- blase::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0("fourier_top_amp_spread (", GENES_TO_USE_COUNT, ")"))
fourier_top_amp_spread_heat
```

### Top Power

We calculate this by using the amplitude of the peak divided by the sum
of total expression

```{r}
top_power_waves <- select_genes_by_fourier_method(processed_MCA_PB_SCE, waves, n_genes = GENES_TO_USE_COUNT, method = "power", force_spread_selection = FALSE)

ggplot2::ggplot(top_power_waves, ggplot2::aes(phase, amplitude, color = r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(processed_MCA_PB_SCE$slingPseudotime_1))) +
    ggplot2::ggtitle("top_power_waves")

top_genes_fourier_top_power <- rownames(top_power_waves)

x <- as.BlaseData(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")
x@genes <- top_genes_fourier_top_power

processed_MCA_PB_SCE <- assign_pseudotime_bins(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")

mapping_results <- c()
for (bulkname in colnames(bulk)) {
    res <- map_best_bin(x, bulkname, bulk)
    mapping_results <- c(mapping_results, res)
    print(res)
}

fourier_top_power_heat <- blase::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0("fourier_top_power (", GENES_TO_USE_COUNT, ")"))
fourier_top_power_heat
```

### Top Power Spread

```{r}
top_power_waves_spread <- select_genes_by_fourier_method(processed_MCA_PB_SCE, waves, n_groups = GENES_TO_USE_COUNT, method = "power", force_spread_selection = TRUE)

ggplot2::ggplot(top_power_waves_spread, ggplot2::aes(phase, amplitude, color = r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(processed_MCA_PB_SCE$slingPseudotime_1))) +
    ggplot2::ggtitle("top_power_waves_spread")

top_genes_fourier_top_power_spread <- rownames(top_power_waves_spread)

x <- as.BlaseData(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")
x@genes <- top_genes_fourier_top_power_spread

processed_MCA_PB_SCE <- assign_pseudotime_bins(processed_MCA_PB_SCE, pseudotime_slot = "slingPseudotime_1", n_bins = BUCKETS_COUNT, split_by = "pseudotime_range")

mapping_results <- c()
for (bulkname in colnames(bulk)) {
    res <- map_best_bin(x, bulkname, bulk)
    mapping_results <- c(mapping_results, res)
    print(res)
}

fourier_top_power_spread_heat <- blase::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0("fourier_top_power_spread (", GENES_TO_USE_COUNT, ")"))
fourier_top_power_spread_heat
```

## Analysing All Gene Lists

Now we can analyse all of these genelists together and compare some
statistics.

### Earth Movers Distance for Gene Scoring (Coverage Scoring)

#### Util

```{r}
# Snippet from: https://cansnippet.bioinfo-fr.net/details.php?id=3
redim_matrix <- function(
    mat,
    target_height = 100,
    target_width = 100,
    summary_func = function(x) mean(x, na.rm = TRUE),
    n_core = 1) {
    if (target_height > nrow(mat) | target_width > ncol(mat)) {
        stop("Input matrix must be bigger than target width and height.")
    }

    seq_height <- round(seq(1, nrow(mat), length.out = target_height + 1))
    seq_width <- round(seq(1, ncol(mat), length.out = target_width + 1))

    # complicate way to write a double for loop
    do.call(rbind, parallel::mclapply(seq_len(target_height), function(i) { # i is row
        vapply(seq_len(target_width), function(j) { # j is column
            summary_func(
                mat[
                    seq(seq_height[i], seq_height[i + 1]),
                    seq(seq_width[j], seq_width[j + 1])
                ]
            )
        }, 0.0)
    }, mc.cores = n_core))
}
```

#### Goal State

We can use the phase calculated for each gene to now score how well the
selected genes cover the lifecycle. A perfect set of genes would look
roughly like a diagonal line from one corner to the other:

```{r}
sim_mat <- matrix(0, ncol = 1000, nrow = 1000)
for (i in seq_len(nrow(sim_mat))) {
    sim_mat[i, i] <- 10 # Squish gene expression onto the place we think it should be
}

reduced_sim_mat <- redim_matrix(sim_mat, target_height = 100, target_width = 100, n_core = N_CORES)

df <- reshape2::melt(reduced_sim_mat, c("x", "y"), value.name = "expression")

ggplot2::ggplot(data = df, ggplot2::aes(x = x, y = y, fill = expression)) +
    ggplot2::geom_tile() +
    ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank()) +
    ggplot2::scale_fill_gradient(
        low = "white",
        high = "red",
        guide = "colorbar"
    ) +
    ggplot2::ggtitle("Goal State")
```

#### Earth Movers Distance

We can also generate a quantified heuristic for how well the genes are
selected. Earth Mover's Distance (EMD) will give a value for how much of
the matrix's mass needs to be moved and how far in order to obtain the
"ideal" state. A lower EMD means that the gene expression matchs the
expected expression in the "ideal" case.

Here, we assume that the perfect case is a straight diagonal line - i.e.
each gene is expressed serially, and does not overlap with other stages.
This isn't realistic, but can help us make a decision about which gene
list will be most informative.

We will only perform this for some of the gene lists, as EMD is a slow
function, however, we show the code that can be used to calculate for
the other gene lists too.

```{r}
get_earthmovers_distance_from_diagonal <- function(expression_matrix, title) {
    # wasserstein - define perfect matrix, then wasserstein versus real matrix
    # Both need to have same *mass* - i.e. expression.

    # 1x1 continuous "perfect" version
    x <- runif(10000)
    x <- x * nrow(expression_matrix)
    x <- ceiling(x)
    y <- x

    sim_mat <- matrix(0, ncol = nrow(expression_matrix), nrow = nrow(expression_matrix))

    for (i in seq_len(length(x))) {
        sim_mat[y[i], x[i]] <- sim_mat[y[i], x[i]] + 1 # Squish gene expression onto the place we think it should be
    }

    # Normalise sim_mat expression to match mass of original matrix
    sim_mat <- sim_mat / rowSums(sim_mat)
    sim_mat <- sim_mat / sum(sim_mat) * sum(expression_matrix)

    # redimension the matrices to speed up EMD approximation
    reduced_mat <- redim_matrix(expression_matrix, target_height = 40, target_width = 40, n_core = N_CORES)
    reduced_sim_mat <- redim_matrix(sim_mat, target_height = 40, target_width = 40, n_core = N_CORES)

    dist <- emd2d(reduced_mat, reduced_sim_mat, max.iter = 750)

    return(dist)
}

heatmap_counts <- normcounts(processed_MCA_PB_SCE)[order(waves$phase), order(processed_MCA_PB_SCE$slingPseudotime_1)]

top_genes_tradeseq_mat <- heatmap_counts[rownames(heatmap_counts) %in% genes_tradeseq, ]
print(paste("Tradeseq:", get_earthmovers_distance_from_diagonal(top_genes_tradeseq_mat, "TradeSeq")))

top_genes_marker_genes_mat <- heatmap_counts[rownames(heatmap_counts) %in% genes_markergenes, ]
print(paste("Markers:", get_earthmovers_distance_from_diagonal(top_genes_marker_genes_mat, "Markers")))

top_genes_bin_markers_mat <- heatmap_counts[rownames(heatmap_counts) %in% genes_markergenes_by_bin, ]
print(paste("Bin Markers:", get_earthmovers_distance_from_diagonal(top_genes_bin_markers_mat, "Bin Markers")))

# top_genes_fourier_top_r2_mat = heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_r2,]
# print(paste("R2:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_r2_mat, "Top r2")))

# top_genes_fourier_top_r2_spread_mat = heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_r2_spread,]
# print(paste("R2 Spread:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_r2_spread_mat, "Top r2 Spread")))

# top_genes_fourier_top_amp_mat = heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_amp,]
# print(paste("Amp:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_amp_mat, "Top Amp")))

# top_genes_fourier_top_amp_spread_mat = heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_amp_spread,]
# print(paste("Amp Spread:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_amp_spread_mat, "Top Amp Spread")))

top_genes_fourier_top_power_mat <- heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_power, ]
print(paste("Power:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_power_mat, "Top Power")))

top_genes_fourier_top_power_spread_mat <- heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_power_spread, ]
print(paste("Power Spread:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_power_spread_mat, "Top Power Spread")))
```

### Fourier Phase Aligned Plotting (Log Expression)

```{r}
top_tradeseq_phases_plot <- gene_selection_matrix(processed_MCA_PB_SCE, waves, genes = genes_tradeseq, target_matrix_size = length(genes_tradeseq), n_cores = N_CORES) + ggplot2::ggtitle("TradeSeq")

top_marker_phases_plot <- gene_selection_matrix(processed_MCA_PB_SCE, waves, genes = genes_markergenes, target_matrix_size = length(genes_markergenes), n_cores = N_CORES) + ggplot2::ggtitle("Top Cluster Markers")

length(genes_markergenes_by_bin)
genes_markergenes_by_bin

top_bin_marker_phases_plot <- gene_selection_matrix(processed_MCA_PB_SCE, waves, genes = genes_markergenes_by_bin, target_matrix_size = length(unique(genes_markergenes_by_bin)), n_cores = N_CORES) + ggplot2::ggtitle("Top Bin Markers")

fourier_top_r2_phases <- gene_selection_matrix(processed_MCA_PB_SCE, waves, genes = top_genes_fourier_top_r2, target_matrix_size = length(top_genes_fourier_top_r2), n_cores = N_CORES) + ggplot2::ggtitle("Top Fourier R2")

fourier_top_r2_spread_phases <- gene_selection_matrix(processed_MCA_PB_SCE, waves, genes = top_genes_fourier_top_r2_spread, target_matrix_size = length(top_genes_fourier_top_r2_spread), n_cores = N_CORES) + ggplot2::ggtitle("Top Fourier R2")

fourier_top_amp_phases <- gene_selection_matrix(processed_MCA_PB_SCE, waves, genes = top_genes_fourier_top_amp, target_matrix_size = length(top_genes_fourier_top_amp), n_cores = N_CORES) + ggplot2::ggtitle("Top Fourier Amplitude")

fourier_top_amp_spread_phases <- gene_selection_matrix(processed_MCA_PB_SCE, waves, genes = top_genes_fourier_top_amp_spread, target_matrix_size = length(top_genes_fourier_top_amp_spread), n_cores = N_CORES) + ggplot2::ggtitle("Top Fourier Amplitude Spread")

fourier_top_power_phases <- gene_selection_matrix(processed_MCA_PB_SCE, waves, genes = top_genes_fourier_top_power, target_matrix_size = length(top_genes_fourier_top_power), n_cores = N_CORES) + ggplot2::ggtitle("Top Fourier Power")

fourier_top_power_spread_phases <- gene_selection_matrix(processed_MCA_PB_SCE, waves, genes = top_genes_fourier_top_power_spread, target_matrix_size = length(top_genes_fourier_top_power_spread), n_cores = N_CORES) + ggplot2::ggtitle("Top Fourier Power Spread")

gridExtra::grid.arrange(
    top_tradeseq_phases_plot,
    top_marker_phases_plot,
    top_bin_marker_phases_plot,
    ncol = 2
)

gridExtra::grid.arrange(
    fourier_top_r2_phases,
    fourier_top_amp_phases,
    fourier_top_power_phases,
    ncol = 2
)

gridExtra::grid.arrange(
    fourier_top_r2_spread_phases,
    fourier_top_amp_spread_phases,
    fourier_top_power_spread_phases,
    ncol = 2
)
```

## Summary

Below, we show a summary of the different results that all methods give.

```{r}
gridExtra::grid.arrange(
    tradeseq_heat,
    tradeseq_tuning,
    ncol = 1
)
gridExtra::grid.arrange(
    markergenes_heat,
    markergenes_tuning,
    ncol = 1
)
gridExtra::grid.arrange(
    markergenes_by_bin_heat,
    markergenes_by_bin_tuning,
    ncol = 1
)
fourier_top_r2_heat
fourier_top_amp_heat
fourier_top_power_heat
fourier_top_r2_spread_heat
fourier_top_amp_spread_heat
fourier_top_power_spread_heat

# upsetInput = list(tradeseq=genes_tradeseq, markergenes=genes_markergenes, markergenes_by_bins=genes_markergenes_by_bin, top_genes_fourier_top_r2=top_genes_fourier_top_r2)
upsetInput <- list(
    tradeseq = genes_tradeseq,
    markergenes = genes_markergenes,
    markergenes_by_bins = genes_markergenes_by_bin,
    top_genes_fourier_top_r2 = top_genes_fourier_top_r2,
    top_genes_fourier_top_amp = top_genes_fourier_top_amp,
    top_genes_fourier_top_power = top_genes_fourier_top_power,
    top_genes_fourier_top_r2_spread = top_genes_fourier_top_r2_spread,
    top_genes_fourier_top_amp_spread = top_genes_fourier_top_amp_spread,
    top_genes_fourier_top_power_spread = top_genes_fourier_top_power_spread
)

upsetPlot <- upset(fromList(upsetInput), nsets = length(upsetInput), )
upsetPlot

library(ggplotify)
gridExtra::grid.arrange(
    tradeseq_heat,
    markergenes_heat,
    markergenes_by_bin_heat,
    as.grob(upsetPlot),
    ncol = 2
)

gridExtra::grid.arrange(
    plotUMAP(processed_MCA_PB_SCE, colour_by = "STAGE_LR"),
    plotUMAP(processed_MCA_PB_SCE, colour_by = "pseudotime_bin"),
    ncol = 2
)
```

## Session Info

```{r}
sessionInfo()
```
