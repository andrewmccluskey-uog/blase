---
title: "gene_selection_comparison"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r loadatgnat}
#library(devtools)
#load_all('/Users/andrewmccluskey/code/PhD/R/atgnat')
```

```{r setup}
library(readxl)
library(atgnat)
library(scran)
library(slingshot)
library(tradeSeq)
library(BiocParallel)
library(UpSetR)
library(emdist)
library(scater)
library(fs)
library(utils)
```

In this article we will look at different methods for gene selection, using the MCA's Plasmodium Berghei Data [Howick et al, 2019](https://dx.doi.org/10.1126/science.aaw2619), and bulk RNA seq of the lifecycle stages [Otto et al, 2004](https://doi.org/10.1186/s12915-014-0086-0).
```{r getData}
root_dir = "articles"
if (!ami::using_ci()) {
  root_dir = tools::R_user_dir("BLASE", "data")
}

article_dir = path(root_dir, "gene_selection_comparison")
if (!dir.exists(article_dir)) {
  dir.create(article_dir)
}

bulk_path = path(article_dir, 'otto_pb_bulk_timepoints', ext="xlsx")
if (!file.exists(bulk_path)) {
  download.file('https://static-content.springer.com/esm/art%3A10.1186%2Fs12915-014-0086-0/MediaObjects/12915_2014_86_MOESM9_ESM.xlsx', bulk_path)
}else {
  print(paste("Using cached", bulk_path))
}

mca_path = path(article_dir, 'MCA-pb', ext="zip")
if (!file.exists(mca_path)) {
  download.file('https://www.malariacellatlas.org/downloads/pb-ch10x-set1.zip', mca_path)
  unzip(mca_path, exdir = path(article_dir, 'MCA-pb'))
}else {
  print(paste("Using cached", mca_path))
}

bulk = as.data.frame(read_excel(bulk_path, range = "FPKM PbA !A4:L5024"))
rownames(bulk) = bulk$`Gene Models (IDs)`
rownames(bulk) = gsub(x=rownames(bulk), pattern="_", replacement="-", fixed=TRUE)
bulk = subset(bulk, , -c(`Gene Models (IDs)`))
rownames(bulk) = paste0(rownames(bulk), '0');

mca_counts_path = path(article_dir, 'MCA-pb','pb-ch10x-set1-ch10x-exp', ext="csv")
sc_readcounts = read.csv(mca_counts_path, row.names=1)
mca_annotation_path = path(article_dir, 'MCA-pb','pb-ch10x-set1-ch10x-data', ext="csv")
sc_annotations = read.csv(mca_annotation_path, row.names=1)
```

```{r}
rownames(sc_annotations) = gsub(x = rownames(sc_annotations), pattern="-", replacement=".", fixed=TRUE)
rownames(sc_readcounts) = gsub(x=rownames(sc_readcounts), pattern="_", replacement="-", fixed=TRUE)

# Remove unshared genes from bulk and sc
bulk = bulk[rownames(bulk) %in% rownames(sc_readcounts),]
sc_readcounts = sc_readcounts[rownames(sc_readcounts) %in% rownames(bulk),]

sce = SingleCellExperiment(assays=list(counts=as.matrix(sc_readcounts)), colData=sc_annotations)
rm(sc_annotations, sc_readcounts)
gc()

# sce = subset(sce, , STAGE_LR != 'gametocyte')

sce <- computeSumFactors(sce)
sce <- logNormCounts(sce)
normcounts(sce) <- exp(logcounts(sce))
reducedDim(sce, "PCA") = as.matrix(cbind(sce@colData["PC_1"], sce@colData["PC_2"]))
sce = runUMAP(sce)

sce <- slingshot(sce, reducedDim = 'UMAP', clusterLabels="STAGE_LR", start.clus="ring")
sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=12, split_by="pseudotime_range")

gridExtra::grid.arrange(
  plotPCA(sce, colour_by="STAGE_LR"),
  plotUMAP(sce, colour_by="STAGE_LR"),
  plotPCA(sce, colour_by="slingPseudotime_1"),
  plotUMAP(sce, colour_by="slingPseudotime_1"),
  plotPCA(sce, colour_by="pseudotime_bin"),
  plotUMAP(sce, colour_by="pseudotime_bin"),
  ncol=2
)

```
## Using TradeSeq
First, we'll use tradeSeq to find the good genes
```{r}
PARALLELISM_CORES = 4
sce <- fitGAM(sce, parallel=T, BPPARAM=MulticoreParam(PARALLELISM_CORES), nknots=6)
associationTestResult <- associationTest(sce, lineages=T, global=F, contrastType="consecutive")
table(sce$pseudotime_bin)
plotUMAP(sce, colour_by="pseudotime_bin")
```
```{r}
genelist = atgnat::get_top_n_genes(associationTestResult, n_genes = 200, lineage = 1)

res = find_best_params(sce,
                       genelist,
                       split_by="pseudotime_range",
                       pseudotime_slot="slingPseudotime_1",
                       bins_count_range = seq.int(8, 16, 2),
                       gene_count_range = seq.int(20, 180, 3))

x = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=14, split_by="pseudotime_range")

tradeseq_tuning = plot_find_best_params_results(res)
```

```{r}
BUCKETS_COUNT = 12
GENES_TO_USE_COUNT = 120
x = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")
x@genes = genelist[1:GENES_TO_USE_COUNT]

genes_tradeseq = x@genes

sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")

plotUMAP(sce, colour="pseudotime_bin")

mapping_results = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(x, bulkname, bulk)
  mapping_results = c(mapping_results, res)
  print(res)
}

tradeseq_heat = atgnat::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0('TradeSeq (', GENES_TO_USE_COUNT,')'))
tradeseq_heat
```

## Using marker genes
```{r}
markers <- scoreMarkers(sce, lfc=1, groups=sce$STAGE_LR)

top_n_markers_per_group = 40
genes=DataFrame()
for (group in names(markers)) {
  group_markers=markers[[group]]
  top_genes=group_markers[order(-group_markers$mean.logFC.cohen),][0:top_n_markers_per_group,]
  top_genes=top_genes[0:top_n_markers_per_group,]
  top_genes
  top_genes$group = group
  genes = rbind(genes,top_genes)
}

genes = DataFrame(genes$mean.logFC.cohen, genes$group)
genelist = rownames(genes)
res = find_best_params(sce,
                       genelist,
                       split_by="pseudotime_range",
                       pseudotime_slot="slingPseudotime_1",
                       bins_count_range = c(12),
                       gene_count_range = c(120))
markergenes_tuning = plot_find_best_params_results(res)
```

```{r}
BUCKETS_COUNT = 12
GENES_TO_USE_COUNT = 120
x = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")
x@genes = genelist[1:GENES_TO_USE_COUNT]
genes_markergenes = x@genes

sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")

mapping_results = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(x, bulkname, bulk)
  mapping_results = c(mapping_results, res)
  print(res)
}

markergenes_heat = atgnat::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0('Marker Genes (', GENES_TO_USE_COUNT,')'))
markergenes_heat
```
## Pseudotime bin marker genes
## Using marker genes
```{r}
sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=12, split_by="pseudotime_range")

markers <- scoreMarkers(sce, lfc=1, groups=sce$pseudotime_bin)

top_n_markers_per_group = 10
genes=DataFrame()
for (group in names(markers)) {
  group_markers=markers[[group]]
  top_genes=group_markers[order(-group_markers$mean.logFC.cohen),][0:top_n_markers_per_group,]
  top_genes=top_genes[0:top_n_markers_per_group,]
  top_genes
  top_genes$group = group
  genes = rbind(genes,top_genes)
}

genes = DataFrame(genes$mean.logFC.cohen, genes$group)
genelist = rownames(genes)

res = find_best_params(sce,
                       genelist,
                       split_by="pseudotime_range",
                       pseudotime_slot="slingPseudotime_1",
                       bins_count_range = c(12),
                       gene_count_range = c(120))
markergenes_by_bin_tuning = plot_find_best_params_results(res)
```


```{r}
BUCKETS_COUNT = 12
GENES_TO_USE_COUNT = 120
x = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")
x@genes = genelist[1:GENES_TO_USE_COUNT]

genes_markergenes_by_bin = x@genes

sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")

mapping_results = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(x, bulkname, bulk)
  mapping_results = c(mapping_results, res)
  print(res)
}

markergenes_by_bin_heat = atgnat::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0('Marker Genes by bin (', GENES_TO_USE_COUNT,')'))
markergenes_by_bin_heat
```

## Using Bozdech Fourier Method

```{r}
library(metR)
sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=12, split_by="pseudotime_range")

counts = normcounts(sce)[,order(sce$slingPseudotime_1)]
waves = as.data.frame(FitWave(as.matrix(counts['PBANKA-0831000',]), 0:20))
waves$gene = rownames(waves)

ggplot2::ggplot(waves, ggplot2::aes(phase, r2, color=amplitude)) +
    ggplot2::geom_point()
ggplot2::ggplot(waves, ggplot2::aes(phase, amplitude, color=r2)) +
    ggplot2::geom_point()
ggplot2::ggplot(waves, ggplot2::aes(phase, amplitude, color=k)) +
    ggplot2::geom_point()

target_to_plot = 'PBANKA-0831000'

toplot = as.data.frame(counts[target_to_plot,order(sce$slingPseudotime_1)])
toplot$pdt = sce$slingPseudotime_1[order(sce$slingPseudotime_1)]
colnames(toplot)[1] = 'count'

# I'm pretty sure the x value for buildwave is wrong here
toplot$wave1 = BuildWave(seq(from=0, to=max(sce$slingPseudotime_1), length.out=nrow(toplot)), wave = FitWave(as.matrix(counts[target_to_plot,]), 1))
toplot$wave1and2 = BuildWave(seq(from=0, to=max(sce$slingPseudotime_1), length.out=nrow(toplot)), wave = FitWave(as.matrix(counts[target_to_plot,]), 1))
toplot$wave1to3 = BuildWave(seq(from=0, to=max(sce$slingPseudotime_1), length.out=nrow(toplot)), wave = FitWave(as.matrix(counts[target_to_plot,]), 1:3))
toplot$wave1toten = BuildWave(seq(from=0, to=max(sce$slingPseudotime_1), length.out=nrow(toplot)), wave = FitWave(as.matrix(counts[target_to_plot,]), 1:10))

ggplot2::ggplot(toplot, ggplot2::aes(pdt, count)) +
    ggplot2::geom_line() +
    ggplot2::geom_line(ggplot2::aes(pdt, wave1, color='wave1')) +
    ggplot2::geom_line(ggplot2::aes(pdt, wave1and2, color='wave1to2')) +
    ggplot2::geom_line(ggplot2::aes(pdt, wave1to3, color='wave1to3')) +
    ggplot2::geom_line(ggplot2::aes(pdt, wave1toten, color='wave1toten')) +
    ggplot2::ggtitle(target_to_plot)

ggplot2::ggplot(toplot, ggplot2::aes(pdt, wave1)) +
    ggplot2::geom_line() +
    ggplot2::ggtitle(target_to_plot)

```

```{r}
counts = normcounts(sce)[,order(sce$slingPseudotime_1)]
waves = DataFrame()
for (gene in rownames(counts)) {
  wave = as.data.frame(FitWave(as.matrix(counts[gene,]), 1))
  rownames(wave) = c(gene)
  waves = rbind(waves, wave)
}
waves = as.data.frame(waves)

waves$phase = waves$phase * (((180/3.141593)/360)*max(sce$slingPseudotime_1)) # pseudotime
waves$gene = rownames(waves)

ggplot2::ggplot(waves, ggplot2::aes(phase, r2, color=amplitude)) +
    ggplot2::geom_point()
ggplot2::ggplot(waves, ggplot2::aes(phase, amplitude, color=r2)) +
    ggplot2::geom_point()
```

### Phase Ordering genes

```{r}
# Snippet from: https://cansnippet.bioinfo-fr.net/details.php?id=3
redim_matrix <- function(
    mat,
    target_height = 100,
    target_width = 100,
    summary_func = function(x) mean(x, na.rm = TRUE),
    n_core = 1
    ) {

    if(target_height > nrow(mat) | target_width > ncol(mat)) {
        stop("Input matrix must be bigger than target width and height.")
    }

    seq_height <- round(seq(1, nrow(mat), length.out = target_height + 1))
    seq_width  <- round(seq(1, ncol(mat), length.out = target_width  + 1))

    # complicate way to write a double for loop
    do.call(rbind, parallel::mclapply(seq_len(target_height), function(i) { # i is row
        vapply(seq_len(target_width), function(j) { # j is column
            summary_func(
                mat[
                    seq(seq_height[i], seq_height[i + 1]),
                    seq(seq_width[j] , seq_width[j + 1] )
                    ]
            )
        }, 0.0)
    }, mc.cores = n_core))
}

# We need to reduce the matrix dims otherwise the heatmap is unwieldy due to having about 5k*5k values. 1k*1k reduces this to about 5% whilst (theoretically) keeping most of the information
heatmap_counts=logcounts(sce)[,order(sce$slingPseudotime_1)]
small_heatmap_counts_ordered = redim_matrix(heatmap_counts[order(waves$phase),], target_height = 1000, target_width = 1000, n_core=2)
heatmap_counts_ordered.df <- reshape2::melt(small_heatmap_counts_ordered, c("gene", "cell"), value.name = "expression")
ggplot2::ggplot(data=heatmap_counts_ordered.df,ggplot2::aes(x=cell,y=gene,fill=expression)) +
  ggplot2::geom_tile() + 
  ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank()) +
  ggplot2::scale_fill_gradient(low = "white",
                      high = "red",
                      guide = "colorbar")

BUCKETS_COUNT = 12
GENES_TO_USE_COUNT = 120

```
### Util
```{r}
get_by_spread = function(waves, n_groups, parameter, top_n_per_group=1) {
  best_waves_in_spread = data.frame()
  stepsize = max(waves$phase)/n_groups
  for(i in seq(from=0, to=max(waves$phase), length.out=n_groups)) {
    waves_in_block = waves[waves$phase>i-stepsize & waves$phase<i+stepsize,]
    # TODO Need to select second best if gene already in the df
    # remove genes in `best_waves_in_spread` from `waves_in_block` and then select best
    best_wave_in_block = waves_in_block[order(-waves_in_block[,parameter]),][1:top_n_per_group,]
    best_wave_in_block = best_wave_in_block[!(rownames(best_wave_in_block) %in% best_waves_in_spread)]
    best_waves_in_spread = rbind(best_waves_in_spread, best_wave_in_block)
  }
  return(best_waves_in_spread)
}
```


### Top r2 waves
```{r}
top_r2_waves = waves[order(-waves$r2),][0:GENES_TO_USE_COUNT,]
ggplot2::ggplot(top_r2_waves, ggplot2::aes(phase, amplitude, color=r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(sce$slingPseudotime_1))) +
    ggplot2::ggtitle('top_r2_waves')

top_genes_fourier_top_r2 = rownames(top_r2_waves)

x = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")
x@genes = top_genes_fourier_top_r2

sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")

any( !(x@genes %in% rownames(x@pseudobulk_bins[[1]])))

mapping_results = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(x, bulkname, bulk)
  mapping_results = c(mapping_results, res)
  print(res)
}

fourier_top_r2_heat = atgnat::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0('fourier_top_r2 (', GENES_TO_USE_COUNT,')'))
fourier_top_r2_heat
```

### Top r2 waves with spread
```{r}
best_r2_waves_spread = get_by_spread(waves, GENES_TO_USE_COUNT, "r2")
ggplot2::ggplot(best_r2_waves_spread, ggplot2::aes(phase, amplitude, color=r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(sce$slingPseudotime_1))) +
    ggplot2::ggtitle('top_r2_waves_spread')

top_genes_fourier_top_r2_spread = rownames(best_r2_waves_spread)

x = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")
x@genes = top_genes_fourier_top_r2_spread

sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")

mapping_results = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(x, bulkname, bulk)
  mapping_results = c(mapping_results, res)
  print(res)
}

fourier_top_r2_spread_heat = atgnat::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0('fourier_top_r2_spread (', GENES_TO_USE_COUNT,')'))
fourier_top_r2_spread_heat
```

### Top amp waves
```{r}
top_amp_waves = waves[order(-waves$amplitude),][0:GENES_TO_USE_COUNT,]
ggplot2::ggplot(top_amp_waves, ggplot2::aes(phase, amplitude, color=r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(sce$slingPseudotime_1))) +
    ggplot2::ggtitle('top_amp_waves')

top_genes_fourier_top_amp = rownames(top_amp_waves)

x = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")
x@genes = top_genes_fourier_top_amp

sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")

mapping_results = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(x, bulkname, bulk)
  mapping_results = c(mapping_results, res)
  print(res)
}

fourier_top_amp_heat = atgnat::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0('fourier_top_amp (', GENES_TO_USE_COUNT,')'))
fourier_top_amp_heat
```
### Top Amp Waves with spread
```{r}
best_amp_waves_spread = get_by_spread(waves, GENES_TO_USE_COUNT, "amplitude")
ggplot2::ggplot(best_amp_waves_spread, ggplot2::aes(phase, amplitude, color=r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(sce$slingPseudotime_1))) +
    ggplot2::ggtitle('top_amp_waves_spread')

top_genes_fourier_top_amp_spread = rownames(best_amp_waves_spread)

x = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")
x@genes = top_genes_fourier_top_amp_spread

sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")

mapping_results = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(x, bulkname, bulk)
  mapping_results = c(mapping_results, res)
  print(res)
}

fourier_top_amp_spread_heat = atgnat::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0('fourier_top_amp_spread (', GENES_TO_USE_COUNT,')'))
fourier_top_amp_spread_heat
```
### Top Power

We calculate this by using the amplitude of the peak divided by the sum of total expression

```{r}
waves$total_expression = rowSums(counts[,order(sce$slingPseudotime_1)])
five_percent_of_pdt = 0.05*max(sce$slingPseudotime_1) # Bozdech et al. use plus or minus 1/48 (i.e. one bulk either side of the peak)

# Review this works with someone because I think it might be questionable
waves$peak_expression = 0
for (gene in rownames(counts)) {
  waves[gene,"peak_expression"] = sum(counts[gene,sce$slingPseudotime_1 > waves[gene,]$phase-five_percent_of_pdt & sce$slingPseudotime_1 < waves[gene,]$phase+five_percent_of_pdt])
  waves[gene,"cellcount_in_peak"] = length(counts[gene,sce$slingPseudotime_1 > waves[gene,]$phase-five_percent_of_pdt & sce$slingPseudotime_1 < waves[gene,]$phase+five_percent_of_pdt])
}
waves$power = waves$amplitude / waves$peak_expression
waves[order(-waves$power),]

top_power_waves = waves[order(-waves$power),][0:GENES_TO_USE_COUNT,]
ggplot2::ggplot(top_power_waves, ggplot2::aes(phase, amplitude, color=r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(sce$slingPseudotime_1))) +
    ggplot2::ggtitle('top_power_waves')

top_genes_fourier_top_power = rownames(top_power_waves)

x = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")
x@genes = top_genes_fourier_top_power

sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")

mapping_results = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(x, bulkname, bulk)
  mapping_results = c(mapping_results, res)
  print(res)
}

fourier_top_power_heat = atgnat::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0('fourier_top_power (', GENES_TO_USE_COUNT,')'))
fourier_top_power_heat

```
### Top Power Spread

``` {r}

best_power_waves_spread = get_by_spread(waves, GENES_TO_USE_COUNT, "power")
ggplot2::ggplot(best_power_waves_spread, ggplot2::aes(phase, amplitude, color=r2)) +
    ggplot2::geom_point() +
    ggplot2::xlim(c(0, max(sce$slingPseudotime_1))) +
    ggplot2::ggtitle('top_power_waves_spread')

top_genes_fourier_top_power_spread = rownames(best_power_waves_spread)

x = as.AtgnatData(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")
x@genes = top_genes_fourier_top_power_spread

sce = assign_pseudotime_bins(sce, pseudotime_slot="slingPseudotime_1", n_bins=BUCKETS_COUNT, split_by="pseudotime_range")

mapping_results = c()
for (bulkname in colnames(bulk)) {
  res = map_best_bin(x, bulkname, bulk)
  mapping_results = c(mapping_results, res)
  print(res)
}

fourier_top_power_spread_heat = atgnat::plot_mapping_result_heatmap(rev(mapping_results)) + ggplot2::ggtitle(paste0('fourier_top_power_spread (', GENES_TO_USE_COUNT,')'))
fourier_top_power_spread_heat
```

## Earth Movers Distance for Gene Scoring (Coverage Scoring)

### Util

```{r}
fourier_phase_aligned_plot = function(heatmap_counts, genes_to_plot, title) {
  phases = heatmap_counts[rownames(heatmap_counts) %in% genes_to_plot,]
  phases = redim_matrix(phases, target_height = nrow(phases), target_width = 1000, n_core=2)
  phases <- reshape2::melt(phases, c("gene", "cell"), value.name = "log_expression")
  plot = ggplot2::ggplot(data=phases,ggplot2::aes(x=cell,y=gene,fill=log_expression)) +
    ggplot2::geom_tile() + 
    ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank()) +
    ggplot2::scale_fill_gradient(low = "white",
                        high = "red",
                        guide = "colorbar",
                        limits=c(0, max(heatmap_counts))) + 
    ggplot2::ggtitle(title)

  return(plot)
}
```

### Goal State
We can use the phase calculated for each gene to now score how well the selected genes cover the lifecycle. A perfect set of genes would look roughly like a diagonal line from one corner to the other:
```{r}
sim_mat = matrix(0, ncol=1000,nrow=1000)
for (i in seq_len(nrow(sim_mat))) {
  sim_mat[i, i] = 10 # Squish gene expression onto the place we think it should be
}

reduced_sim_mat = redim_matrix(sim_mat, target_height = 100, target_width = 100, n_core=2)

df <- reshape2::melt(reduced_sim_mat, c("x", "y"), value.name = "expression")

ggplot2::ggplot(data=df,ggplot2::aes(x=x,y=y,fill=expression)) +
    ggplot2::geom_tile() + 
    ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank()) +
    ggplot2::scale_fill_gradient(low = "white",
                        high = "red",
                        guide = "colorbar") + 
    ggplot2::ggtitle("Goal State")

```
### Normalised Count Plotting
```{r}

get_earthmovers_distance_from_diagonal = function (expression_matrix, title) {
  # wasserstein - define perfect matrix, then wasserstein versus real matrix
  # Both need to have same *mass* - i.e. expression.
  
  # 1x1 continuous "perfect" version
  x = runif(10000)
  x = x*nrow(expression_matrix)
  x = ceiling(x)
  y = x
  
  sim_mat = matrix(0, ncol=nrow(expression_matrix),nrow=nrow(expression_matrix))
    
  for (i in seq_len(length(x))) {
    sim_mat[y[i], x[i]] = sim_mat[y[i], x[i]] + 1 # Squish gene expression onto the place we think it should be
  }

  # Normalise sim_mat expression to match mass of original matrix
  sim_mat <- sim_mat/rowSums(sim_mat)
  sim_mat <- sim_mat/sum(sim_mat) * sum(expression_matrix)
  
  # redimension the matrices to speed up EMD approximation
  reduced_mat = redim_matrix(expression_matrix, target_height = nrow(expression_matrix), target_width = nrow(expression_matrix), n_core=2)
  reduced_sim_mat = redim_matrix(sim_mat, target_height = nrow(sim_mat), target_width = nrow(expression_matrix), n_core=2)
  
  dist = emd2d(reduced_mat, reduced_sim_mat, max.iter=5000)
  
  ####
  df_sim <- reshape2::melt(reduced_sim_mat, c("x", "y"), value.name = "expression")
  df_real <- reshape2::melt(reduced_mat, c("x", "y"), value.name = "expression")

  plot = gridExtra::grid.arrange(
    ggplot2::ggplot(data=df_sim,ggplot2::aes(x=x,y=y,fill=expression)) +
    ggplot2::geom_tile() + 
    ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank()) +
    ggplot2::scale_fill_gradient(low = "white",
                        high = "red",
                        guide = "colorbar") + 
    ggplot2::ggtitle("Goal State"),
    ggplot2::ggplot(data=df_real,ggplot2::aes(x=x,y=y,fill=expression)) +
    ggplot2::geom_tile() + 
    ggplot2::theme(axis.text.x = ggplot2::element_blank(), axis.text.y = ggplot2::element_blank()) +
    ggplot2::scale_fill_gradient(low = "white",
                        high = "red",
                        guide = "colorbar") + 
    ggplot2::ggtitle("Real State "),
    ncol=2,
    top=grid::textGrob(paste(title, dist))
  )
  return(plot)
  ####
  
  #return(dist)
}

heatmap_counts=normcounts(sce)[order(waves$phase),order(sce$slingPseudotime_1)]

top_genes_tradeseq_mat = heatmap_counts[rownames(heatmap_counts) %in% genes_tradeseq,]
print(paste("Tradeseq:", get_earthmovers_distance_from_diagonal(top_genes_tradeseq_mat, "TradeSeq")))

top_genes_marker_genes_mat = heatmap_counts[rownames(heatmap_counts) %in% genes_markergenes,]
print(paste("Markers:", get_earthmovers_distance_from_diagonal(top_genes_marker_genes_mat, "Markers")))

top_genes_bin_markers_mat = heatmap_counts[rownames(heatmap_counts) %in% genes_markergenes_by_bin,]
print(paste("Bin Markers:", get_earthmovers_distance_from_diagonal(top_genes_bin_markers_mat, "Bin Markers")))

top_genes_fourier_top_r2_mat = heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_r2,]
print(paste("R2:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_r2_mat, "Top r2")))

top_genes_fourier_top_r2_spread_mat = heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_r2_spread,]
print(paste("R2 Spread:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_r2_spread_mat, "Top r2 Spread")))

top_genes_fourier_top_amp_mat = heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_amp,]
print(paste("Amp:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_amp_mat, "Top Amp")))

top_genes_fourier_top_amp_spread_mat = heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_amp_spread,]
print(paste("Amp Spread:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_amp_spread_mat, "Top Amp Spread")))

top_genes_fourier_top_power_mat = heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_power,]
print(paste("Power:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_power_mat, "Top Power")))

#top_genes_fourier_top_power_spread
#rownames(top_genes_fourier_top_power_spread_mat)

top_genes_fourier_top_power_spread_mat = heatmap_counts[rownames(heatmap_counts) %in% top_genes_fourier_top_power_spread,]
print(paste("Power Spread:", get_earthmovers_distance_from_diagonal(top_genes_fourier_top_power_spread_mat, "Top Power Spread")))
```

## Fourier Phase Aligned Plotting (Log Expression)

```{r}
heatmap_counts=logcounts(sce)[order(waves$phase),order(sce$slingPseudotime_1)]

top_tradeseq_phases_plot = fourier_phase_aligned_plot(heatmap_counts, genes_tradeseq, "TradeSeq")
top_marker_phases_plot = fourier_phase_aligned_plot(heatmap_counts, genes_markergenes, "Top Cluster Markers")
top_bin_marker_phases_plot = fourier_phase_aligned_plot(heatmap_counts, genes_markergenes_by_bin, "Top Bin Markers")
fourier_top_r2_phases = fourier_phase_aligned_plot(heatmap_counts, top_genes_fourier_top_r2, "Top Fourier R2")
fourier_top_amp_phases = fourier_phase_aligned_plot(heatmap_counts, top_genes_fourier_top_amp, "Top Fourier Amplitude")
fourier_top_power_phases = fourier_phase_aligned_plot(heatmap_counts, top_genes_fourier_top_power, "Top Fourier Power")
fourier_top_r2_spread_phases = fourier_phase_aligned_plot(heatmap_counts, top_genes_fourier_top_r2_spread, "Top Fourier R2 Spread")
fourier_top_amp_spread_phases = fourier_phase_aligned_plot(heatmap_counts, top_genes_fourier_top_amp_spread, "Top Fourier Amp Spread")
fourier_top_power_spread_phases = fourier_phase_aligned_plot(heatmap_counts, top_genes_fourier_top_power_spread, "Top Fourier Power Spread")

gridExtra::grid.arrange(
  top_tradeseq_phases_plot,
  top_marker_phases_plot,
  top_bin_marker_phases_plot,
  ncol=2
)

gridExtra::grid.arrange(
  fourier_top_r2_phases,
  fourier_top_amp_phases,
  fourier_top_power_phases,
  ncol=2
)

gridExtra::grid.arrange(
  fourier_top_r2_spread_phases,
  fourier_top_amp_spread_phases,
  fourier_top_power_spread_phases,
  ncol=2
)
```

## Summary
```{r}
gridExtra::grid.arrange(
  tradeseq_heat,
  tradeseq_tuning,
  ncol=1
)
gridExtra::grid.arrange(
  markergenes_heat,
  markergenes_tuning,
  ncol=1
)
gridExtra::grid.arrange(
  markergenes_by_bin_heat,
  markergenes_by_bin_tuning,
  ncol=1
)
fourier_top_r2_heat
fourier_top_amp_heat
fourier_top_power_heat
fourier_top_r2_spread_heat
fourier_top_amp_spread_heat
fourier_top_power_spread_heat

#upsetInput = list(tradeseq=genes_tradeseq, markergenes=genes_markergenes, markergenes_by_bins=genes_markergenes_by_bin, top_genes_fourier_top_r2=top_genes_fourier_top_r2)
upsetInput = list(
  tradeseq=genes_tradeseq,
  markergenes=genes_markergenes,
  markergenes_by_bins=genes_markergenes_by_bin, # TODO why is this shown as 50? It's length is 60
  top_genes_fourier_top_r2=top_genes_fourier_top_r2,
  top_genes_fourier_top_amp=top_genes_fourier_top_amp,
  top_genes_fourier_top_power=top_genes_fourier_top_power,
  top_genes_fourier_top_r2_spread=top_genes_fourier_top_r2_spread,
  top_genes_fourier_top_amp_spread=top_genes_fourier_top_amp_spread,
  top_genes_fourier_top_power_spread=top_genes_fourier_top_power_spread
  )

upsetPlot = upset(fromList(upsetInput), nsets=length(upsetInput), )
upsetPlot

library(ggplotify)
gridExtra::grid.arrange(
  tradeseq_heat,
  markergenes_heat,
  markergenes_by_bin_heat,
  as.grob(upsetPlot),
  ncol=2
)

gridExtra::grid.arrange(
  plotUMAP(sce, colour_by="STAGE_LR"),
  plotUMAP(sce, colour_by="pseudotime_bin"),
  ncol=2
)
```

``` {r}
session_info()
```
